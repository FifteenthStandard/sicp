<!DOCTYPE html>
<html lang="en-AU">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SICP | Structure and Interpretation of Computer Programs</title>
  <link rel="icon" href="favicon.png">
  <link rel="stylesheet" href="css/layout.css">
  <link rel="stylesheet" href="css/style.css">
  <script src="js/Editor.js" type="module"></script>
</head>

<body>
<header>
  <hgroup>
    <h1>Structure and Interpretation of Computer Programs</h1>
    <p>Second edition</p>
  </hgroup>
  <address>
    <p>
      Harold Abelson and Gerald Jay Sussman with Julie Sussman <br>
      foreword by Alan J. Perlis
    </p>
    <p>
      The MIT Press <br>
      Cambridge, Massachusetts&emsp;London, England
    </p>
    <p>
      McGraw-Hill Book Company <br>
      New York&emsp;St. Louis&emsp;San Francisco&emsp;Montreal&emsp;Toronto 
    </p>
  </address>
</header>

<main>
<section id="s0">
<section id="s0.1">
  <h3><a href="#s0.1">Foreward</a></h3>
  <p>
    Educators, generals, dieticians, psychologists, and parents program.
    Armies, students, and some societies are programmed. An assault on large
    problems employs a succession of programs, most of which spring into
    existence en route. These programs are rife with issues that appear to be
    particular to the problem at hand. To appreciate programming as an
    intellectual activity in its own right you must turn to computer
    programming; you must read and write computer programs—many of them. It
    doesn’t matter much what the programs are about or what applications they
    serve. What does matter is how well they perform and how smoothly they fit
    with other programs in the creation of still greater programs. The
    programmer must seek both perfection of part and adequacy of collection. In
    this book the use of “program” is focused on the creation, execution, and
    study of programs written in a dialect of Lisp for execution on a digital
    computer. Using Lisp we restrict or limit not what we may program, but only
    the notation for our program descriptions.
  </p>
  <p>
    Our traffic with the subject matter of this book involves us with three
    foci of phenomena: the human mind, collections of computer programs, and
    the computer. Every computer program is a model, hatched in the mind, of a
    real or mental process. These processes, arising from human experience and
    thought, are huge in number, intricate in detail, and at any time only
    partially understood. They are modeled to our permanent satisfaction rarely
    by our computer programs. Thus even though our programs are carefully
    handcrafted discrete collections of symbols, mosaics of interlocking
    functions, they continually evolve: we change them as our perception of the
    model deepens, enlarges, generalizes until the model ultimately attains a
    metastable place within still another model with which we struggle. The
    source of the exhilaration associated with computer programming is the
    continual unfolding within the mind and on the computer of mechanisms
    expressed as programs and the explosion of perception they generate. If art
    interprets our dreams, the computer executes them in the guise of programs!
  </p>
  <p>
    For all its power, the computer is a harsh taskmaster. Its programs must be
    correct, and what we wish to say must be said accurately in every detail.
    As in every other symbolic activity, we become convinced of program truth
    through argument. Lisp itself can be assigned a semantics (another model,
    by the way), and if a program’s function can be specified, say, in the
    predicate calculus, the proof methods of logic can be used to make an
    acceptable correctness argument. Unfortunately, as programs get large and
    complicated, as they almost always do, the adequacy, consistency, and
    correctness of the specifications themselves become open to doubt, so that
    complete formal arguments of correctness seldom accompany large programs.
    Since large programs grow from small ones, it is crucial that we develop an
    arsenal of standard program structures of whose correctness we have become
    sure—we call them idioms—and learn to combine them into larger structures
    using organizational techniques of proven value. These techniques are
    treated at length in this book, and understanding them is essential to
    participation in the Promethean enterprise called programming. More than
    anything else, the uncovering and mastery of powerful organizational
    techniques accelerates our ability to create large, significant programs.
    Conversely, since writing large programs is very taxing, we are stimulated
    to invent new methods of reducing the mass of function and detail to be
    fitted into large programs.
  </p>
  <p>
    Unlike programs, computers must obey the laws of physics. If they wish to
    perform rapidly—a few nanoseconds per state change—they must transmit
    electrons only small distances (at most 1 1/2 feet). The heat generated by
    the huge number of devices so concentrated in space has to be removed. An
    exquisite engineering art has been developed balancing between multiplicity
    of function and density of devices. In any event, hardware always operates
    at a level more primitive than that at which we care to program. The
    processes that transform our Lisp programs to “machine” programs are
    themselves abstract models which we program. Their study and creation give
    a great deal of insight into the organizational programs associated with
    programming arbitrary models. Of course the computer itself can be so
    modeled. Think of it: the behavior of the smallest physical switching
    element is modeled by quantum mechanics described by differential equations
    whose detailed behavior is captured by numerical approximations represented
    in computer programs executing on computers composed of ...!
  </p>
  <p>
    It is not merely a matter of tactical convenience to separately identify
    the three foci. Even though, as they say, it’s all in the head, this
    logical separation induces an acceleration of symbolic traffic between
    these foci whose richness, vitality, and potential is exceeded in human
    experience only by the evolution of life itself. At best, relationships
    between the foci are metastable. The computers are never large enough or
    fast enough. Each breakthrough in hardware technology leads to more massive
    programming enterprises, new organizational principles, and an enrichment
    of abstract models. Every reader should ask himself periodically “Toward
    what end, toward what end?”—but do not ask it too often lest you pass up
    the fun of programming for the constipation of bittersweet philosophy.
  </p>
  <p>
    Among the programs we write, some (but never enough) perform a precise
    mathematical function such as sorting or finding the maximum of a sequence
    of numbers, determining primality, or finding the square root. We call such
    programs algorithms, and a great deal is known of their optimal behavior,
    particularly with respect to the two important parameters of execution time
    and data storage requirements. A programmer should acquire good algorithms
    and idioms. Even though some programs resist precise specifications, it is
    the responsibility of the programmer to estimate, and always to attempt to
    improve, their performance.
  </p>
  <p>
    Lisp is a survivor, having been in use for about a quarter of a century.
    Among the active programming languages only Fortran has had a longer life.
    Both languages have supported the programming needs of important areas of
    application, Fortran for scientific and engineering computation and Lisp
    for artificial intelligence. These two areas continue to be important, and
    their programmers are so devoted to these two languages that Lisp and
    Fortran may well continue in active use for at least another
    quarter-century.
  </p>
  <p>
    Lisp changes. The Scheme dialect used in this text has evolved from the
    original Lisp and differs from the latter in several important ways,
    including static scoping for variable binding and permitting functions to
    yield functions as values. In its semantic structure Scheme is as closely
    akin to Algol 60 as to early Lisps. Algol 60, never to be an active
    language again, lives on in the genes of Scheme and Pascal. It would be
    difficult to find two languages that are the communicating coin of two more
    different cultures than those gathered around these two languages. Pascal
    is for building pyramids—imposing, breathtaking, static structures built by
    armies pushing heavy blocks into place. Lisp is for building
    organisms—imposing, breathtaking, dynamic structures built by squads
    fitting fluctuating myriads of simpler organisms into place. The organizing
    principles used are the same in both cases, except for one extraordinarily
    important difference: The discretionary exportable functionality entrusted
    to the individual Lisp programmer is more than an order of magnitude
    greater than that to be found within Pascal enterprises. Lisp programs
    inflate libraries with functions whose utility transcends the application
    that produced them. The list, Lisp’s native data structure, is largely
    responsible for such growth of utility. The simple structure and natural
    applicability of lists are reflected in functions that are amazingly
    nonidiosyncratic. In Pascal the plethora of declarable data structures
    induces a specialization within functions that inhibits and penalizes
    casual cooperation. It is better to have 100 functions operate on one data
    structure than to have 10 functions operate on 10 data structures. As a
    result the pyramid must stand unchanged for a millennium; the organism must
    evolve or perish.
  </p>
  <p>
    To illustrate this difference, compare the treatment of material and
    exercises within this book with that in any first-course text using Pascal.
    Do not labor under the illusion that this is a text digestible at MIT only,
    peculiar to the breed found there. It is precisely what a serious book on
    programming Lisp must be, no matter who the student is or where it is used.
  </p>
  <p>
    Note that this is a text about programming, unlike most Lisp books, which
    are used as a preparation for work in artificial intelligence. After all,
    the critical programming concerns of software engineering and artificial
    intelligence tend to coalesce as the systems under investigation become
    larger. This explains why there is such growing interest in Lisp outside of
    artificial intelligence.
  </p>
  <p>
    As one would expect from its goals, artificial intelligence research
    generates many significant programming problems. In other programming
    cultures this spate of problems spawns new languages. Indeed, in any very
    large programming task a useful organizing principle is to control and
    isolate traffic within the task modules via the invention of language.
    These languages tend to become less primitive as one approaches the
    boundaries of the system where we humans interact most often. As a result,
    such systems contain complex language-processing functions replicated many
    times. Lisp has such a simple syntax and semantics that parsing can be
    treated as an elementary task. Thus parsing technology plays almost no role
    in Lisp programs, and the construction of language processors is rarely an
    impediment to the rate of growth and change of large Lisp systems. Finally,
    it is this very simplicity of syntax and semantics that is responsible for
    the burden and freedom borne by all Lisp programmers. No Lisp program of
    any size beyond a few lines can be written without being saturated with
    discretionary functions. Invent and fit; have fits and reinvent! We toast
    the Lisp programmer who pens his thoughts within nests of parentheses.
  </p>
  <address>
    Alan J. Perlis <br>
    New Haven, Connecticut
  </address>
</section>

<section id="s0.2">
  <h3><a href="#s0.2">Preface to the Second Edition</a></h3>
  <blockquote>
    <p>
      Is it possible that software is not like anything else, that it is meant
      to be discarded: that the whole point is to always see it as a soap
      bubble?
    </p>
    <address>
      Alan J. Perlis
    </address>
  </blockquote>
  <p>
    The material in this book has been the basis of MIT’s entry-level computer
    science subject since 1980. We had been teaching this material for four
    years when the first edition was published, and twelve more years have
    elapsed until the appearance of this second edition. We are pleased that
    our work has been widely adopted and incorporated into other texts. We have
    seen our students take the ideas and programs in this book and build them
    in as the core of new computer systems and languages. In literal
    realization of an ancient Talmudic pun, our students have become our
    builders. We are lucky to have such capable students and such accomplished
    builders.
  </p>
  <p>
    In preparing this edition, we have incorporated hundreds of clarifications
    suggested by our own teaching experience and the comments of colleagues at
    MIT and elsewhere. We have redesigned most of the major programming systems
    in the book, including the generic-arithmetic system, the interpreters, the
    register-machine simulator, and the compiler; and we have rewritten all the
    program examples to ensure that any Scheme implementation conforming to the
    IEEE Scheme standard (IEEE 1990) will be able to run the code.
  </p>
  <p>
    This edition emphasizes several new themes. The most important of these is
    the central role played by different approaches to dealing with time in
    computational models: objects with state, concurrent programming,
    functional programming, lazy evaluation, and nondeterministic programming.
    We have included new sections on concurrency and nondeterminism, and we
    have tried to integrate this theme throughout the book.
  </p>
  <p>
    The first edition of the book closely followed the syllabus of our MIT
    one-semester subject. With all the new material in the second edition, it
    will not be possible to cover everything in a single semester, so the
    instructor will have to pick and choose. In our own teaching, we sometimes
    skip the section on logic programming (section <a href="#s4.4">4.4</a>), we
    have students use the register-machine simulator but we do not cover its
    implementation (section <a href="#s5.2">5.2</a>), and we give only a
    cursory overview of the compiler (section <a href="#s5.5">5.5</a>). Even
    so, this is still an intense course. Some instructors may wish to cover
    only the first three or four chapters, leaving the other material for
    subsequent courses.
  </p>
  <p>
    The World-Wide-Web site <a href="https://mitpress.mit.edu/sicp"
    >mitpress.mit.edu/sicp</a> provides support for users of this book. This
    includes programs from the book, sample programming assignments,
    supplementary materials, and downloadable implementations of the Scheme
    dialect of Lisp.
  </p>
</section>

<section id="s0.3">
  <h3><a href="#s0.3">Preface to the First Edition</a></h3>
  <blockquote>
    <p>
      A computer is like a violin. You can imagine a novice trying first a
      phonograph and then a violin. The latter, he says, sounds terrible. That
      is the argument we have heard from our humanists and most of our computer
      scientists. Computer programs are good, they say, for particular
      purposes, but they aren’t flexible. Neither is a violin, or a typewriter,
      until you learn how to use it.
    </p>
    <address>
      Marvin Minsky, “Why Programming Is a Good Medium for Expressing
      Poorly-Understood and Sloppily-Formulated Ideas”
    </address>
  </blockquote>
  <p>
    “The Structure and Interpretation of Computer Programs” is the entry-level
    subject in computer science at the Massachusetts Institute of Technology.
    It is required of all students at MIT who major in electrical engineering
    or in computer science, as one-fourth of the “common core curriculum,”
    which also includes two subjects on circuits and linear systems and a
    subject on the design of digital systems. We have been involved in the
    development of this subject since 1978, and we have taught this material in
    its present form since the fall of 1980 to between 600 and 700 students
    each year. Most of these students have had little or no prior formal
    training in computation, although many have played with computers a bit and
    a few have had extensive programming or hardware-design experience.
  </p>
  <p>
    Our design of this introductory computer-science subject reflects two major
    concerns. First, we want to establish the idea that a computer language is
    not just a way of getting a computer to perform operations but rather that
    it is a novel formal medium for expressing ideas about methodology. Thus,
    programs must be written for people to read, and only incidentally for
    machines to execute. Second, we believe that the essential material to be
    addressed by a subject at this level is not the syntax of particular
    programming-language constructs, nor clever algorithms for computing
    particular functions efficiently, nor even the mathematical analysis of
    algorithms and the foundations of computing, but rather the techniques used
    to control the intellectual complexity of large software systems.
  </p>
  <p>
    Our goal is that students who complete this subject should have a good feel
    for the elements of style and the aesthetics of programming. They should
    have command of the major techniques for controlling complexity in a large
    system. They should be capable of reading a 50-page-long program, if it is
    written in an exemplary style. They should know what not to read, and what
    they need not understand at any moment. They should feel secure about
    modifying a program, retaining the spirit and style of the original author.
  </p>
  <p>
    These skills are by no means unique to computer programming. The techniques
    we teach and draw upon are common to all of engineering design. We control
    complexity by building abstractions that hide details when appropriate. We
    control complexity by establishing conventional interfaces that enable us
    to construct systems by combining standard, well-understood pieces in a
    “mix and match” way. We control complexity by establishing new languages
    for describing a design, each of which emphasizes particular aspects of the
    design and deemphasizes others.
  </p>
  <p>
    Underlying our approach to this subject is our conviction that “computer
    science” is not a science and that its significance has little to do with
    computers. The computer revolution is a revolution in the way we think and
    in the way we express what we think. The essence of this change is the
    emergence of what might best be called procedural epistemology—the study of
    the structure of knowledge from an imperative point of view, as opposed to
    the more declarative point of view taken by classical mathematical
    subjects. Mathematics provides a framework for dealing precisely with
    notions of “what is.” Computation provides a framework for dealing
    precisely with notions of “how to.”
  </p>
  <p>
    In teaching our material we use a dialect of the programming language Lisp.
    We never formally teach the language, because we don’t have to. We just use
    it, and students pick it up in a few days. This is one great advantage of
    Lisp-like languages: They have very few ways of forming compound
    expressions, and almost no syntactic structure. All of the formal
    properties can be covered in an hour, like the rules of chess. After a
    short time we forget about syntactic details of the language (because there
    are none) and get on with the real issues—figuring out what we want to
    compute, how we will decompose problems into manageable parts, and how we
    will work on the parts. Another advantage of Lisp is that it supports (but
    does not enforce) more of the large-scale strategies for modular
    decomposition of programs than any other language we know. We can make
    procedural and data abstractions, we can use higher-order functions to
    capture common patterns of usage, we can model local state using assignment
    and data mutation, we can link parts of a program with streams and delayed
    evaluation, and we can easily implement embedded languages. All of this is
    embedded in an interactive environment with excellent support for
    incremental program design, construction, testing, and debugging. We thank
    all the generations of Lisp wizards, starting with John McCarthy, who have
    fashioned a fine tool of unprecedented power and elegance.
  </p>
  <p>
    Scheme, the dialect of Lisp that we use, is an attempt to bring together
    the power and elegance of Lisp and Algol. From Lisp we take the
    metalinguistic power that derives from the simple syntax, the uniform
    representation of programs as data objects, and the garbage-collected
    heap-allocated data. From Algol we take lexical scoping and block
    structure, which are gifts from the pioneers of programming-language design
    who were on the Algol committee. We wish to cite John Reynolds and Peter
    Landin for their insights into the relationship of Church’s lambda calculus
    to the structure of programming languages. We also recognize our debt to
     the mathematicians who scouted out this territory decades before computers
     appeared on the scene. These pioneers include Alonzo Church, Barkley
     Rosser, Stephen Kleene, and Haskell Curry.
  </p>
</section>

<section id="s0.4">
  <h3><a href="#s0.4">Acknowledgements</a></h3>
  <p>
    We would like to thank the many people who have helped us develop this book
    and this curriculum.
  </p>
  <p>
    Our subject is a clear intellectual descendant of “6.231,” a wonderful
    subject on programming linguistics and the lambda calculus taught at MIT in
    the late 1960s by Jack Wozencraft and Arthur Evans, Jr.
  </p>
  <p>
    We owe a great debt to Robert Fano, who reorganized MIT’s introductory
    curriculum in electrical engineering and computer science to emphasize the
    principles of engineering design. He led us in starting out on this
    enterprise and wrote the first set of subject notes from which this book
    evolved.
  </p>
  <p>
    Much of the style and aesthetics of programming that we try to teach were
    developed in conjunction with Guy Lewis Steele Jr., who collaborated with
    Gerald Jay Sussman in the initial development of the Scheme language. In
    addition, David Turner, Peter Henderson, Dan Friedman, David Wise, and Will
    Clinger have taught us many of the techniques of the functional programming
    community that appear in this book.
  </p>
  <p>
    Joel Moses taught us about structuring large systems. His experience with
    the Macsyma system for symbolic computation provided the insight that one
    should avoid complexities of control and concentrate on organizing the data
    to reflect the real structure of the world being modeled.
  </p>
  <p>
    Marvin Minsky and Seymour Papert formed many of our attitudes about
    programming and its place in our intellectual lives. To them we owe the
    understanding that computation provides a means of expression for exploring
    ideas that would otherwise be too complex to deal with precisely. They
    emphasize that a student’s ability to write and modify programs provides a
    powerful medium in which exploring becomes a natural activity.
  </p>
  <p>
    We also strongly agree with Alan Perlis that programming is lots of fun and
    we had better be careful to support the joy of programming. Part of this
    joy derives from observing great masters at work. We are fortunate to have
    been apprentice programmers at the feet of Bill Gosper and Richard
    Greenblatt.
  </p>
  <p>
    It is difficult to identify all the people who have contributed to the
    development of our curriculum. We thank all the lecturers, recitation
    instructors, and tutors who have worked with us over the past fifteen years
    and put in many extra hours on our subject, especially Bill Siebert, Albert
    Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn
    Stein, and Peter Szolovits. We would like to specially acknowledge the
    outstanding teaching contributions of Franklyn Turbak, now at Wellesley;
    his work in undergraduate instruction set a standard that we can all aspire
    to. We are grateful to Jerry Saltzer and Jim Miller for helping us grapple
    with the mysteries of concurrency, and to Peter Szolovits and David
    McAllester for their contributions to the exposition of nondeterministic
    evaluation in chapter 4.
  </p>
  <p>
    Many people have put in significant effort presenting this material at
    other universities. Some of the people we have worked closely with are
    Jacob Katzenelson at the Technion, Hardy Mayer at the University of
    California at Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue, and Jan
    Komorowski at the Norwegian University of Science and Technology. We are
    exceptionally proud of our colleagues who have received major teaching
    awards for their adaptations of this subject at other universities,
    including Kenneth Yip at Yale, Brian Harvey at the University of California
    at Berkeley, and Dan Huttenlocher at Cornell.
  </p>
  <p>
    Al Moyé arranged for us to teach this material to engineers at
    Hewlett-Packard, and for the production of videotapes of these lectures. We
    would like to thank the talented instructors—in particular Jim Miller, Bill
    Siebert, and Mike Eisenberg—who have designed continuing education courses
    incorporating these tapes and taught them at universities and industry all
    over the world.
  </p>
  <p>
    Many educators in other countries have put in significant work translating
    the first edition. Michel Briand, Pierre Chamard, and André Pic produced a
    French edition; Susanne Daniels-Herold produced a German edition; and Fumio
    Motoyoshi produced a Japanese edition. We do not know who produced the
    Chinese edition, but we consider it an honor to have been selected as the
    subject of an “unauthorized” translation.
  </p>
  <p>
    It is hard to enumerate all the people who have made technical
    contributions to the development of the Scheme systems we use for
    instructional purposes. In addition to Guy Steele, principal wizards have
    included Chris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas, and
    Stephen Adams. Others who have put in significant time are Richard
    Stallman, Alan Bawden, Kent Pitman, Jon Taft, Neil Mayle, John Lamping,
    Gwyn Osnos, Tracy Larrabee, George Carrette, Soma Chaudhuri, Bill
    Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd Cass, Patrick
    O’Donnell, Kevin Theobald, Daniel Weise, Kenneth Sinclair, Anthony
    Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth Shyu.
  </p>
  <p>
    Beyond the MIT implementation, we would like to thank the many people who
    worked on the IEEE Scheme standard, including William Clinger and Jonathan
    Rees, who edited the R4RS, and Chris Haynes, David Bartley, Chris Hanson,
    and Jim Miller, who prepared the IEEE standard.
  </p>
  <p>
    Dan Friedman has been a long-time leader of the Scheme community. The
    community’s broader work goes beyond issues of language design to encompas
    significant educational innovations, such as the high-school curriculum
    based on EdScheme by Schemer’s Inc., and the wonderful books by Mike
    Eisenberg and by Brian Harvey and Matthew Wright.
  </p>
  <p>
    We appreciate the work of those who contributed to making this a real book,
    especially Terry Ehling, Larry Cohen, and Paul Bethge at the MIT Press.
    Ella Mazel found the wonderful cover image. For the second edition we are
    particularly grateful to Bernard and Ella Mazel for help with the book
    design, and to David Jones, TEX wizard extraordinaire. We also are indebted
    to those readers who made penetrating comments on the new draft: Jacob
    Katzenelson, Hardy Mayer, Jim Miller, and especially Brian Harvey, who did
    unto this book as Julie did unto his book Simply Scheme.
  </p>
  <p>
    Finally, we would like to acknowledge the support of the organizations that
    have encouraged this work over the years, including support from
    Hewlett-Packard, made possible by Ira Goldstein and Joel Birnbaum, and
    support from DARPA, made possible by Bob Kahn.
  </p>
</section>
</section>

<section id="s1">
<section id="s1.0">
  <h2><a href="#s1">Chapter 1: Building Abstractions with Procedures</a></h2>
  <blockquote>
    <p>
      The acts of the mind, wherein it exerts its power over simple ideas, are
      chiefly these three: 1. Combining several simple ideas into one compound
      one, and thus all complex ideas are made. 2. The second is bringing two
      ideas, whether simple or complex, together, and setting them by one
      another so as to take a view of them at once, without uniting them into
      one, by which it gets all its ideas of relations. 3. The third is
      separating them from all other ideas that accompany them in their real
      existence: this is called abstraction, and thus all its general ideas are
      made.
    </p>
    <address>
      John Locke, <em>An Essay Concerning Human Understanding</em> (1690)
    </address>
  </blockquote>
  <p>
    We are about to study the idea of a <em>computational process</em>.
    Computational processes are abstract beings that inhabit computers. As they
    evolve, processes manipulate other abstract things called <em>data</em>.
    The evolution of a process is directed by a pattern of rules called a
    <em>program</em>. People create programs to direct processes. In effect, we
    conjure the spirits of the computer with our spells.
  </p>
  <p>
    A computational process is indeed much like a sorcerer’s idea of a spirit.
    It cannot be seen or touched. It is not composed of matter at all. However,
    it is very real. It can perform intellectual work. It can answer questions.
    It can affect the world by disbursing money at a bank or by controlling a
    robot arm in a factory. The programs we use to conjure processes are like a
    sorcerer’s spells. They are carefully composed from symbolic expressions in
    arcane and esoteric <em>programming languages</em> that prescribe the tasks
    we want our processes to perform.
  </p>
  <p>
    A computational process, in a correctly working computer, executes programs
    precisely and accurately. Thus, like the sorcerer’s apprentice, novice
    programmers must learn to understand and to anticipate the consequences of
    their conjuring. Even small errors (usually called <em>bugs</em> or
    <em>glitches</em>) in programs can have complex and unanticipated
    consequences.
  </p>
  <p>
    Fortunately, learning to program is considerably less dangerous than
    learning sorcery, because the spirits we deal with are conveniently
    contained in a secure way. Real-world programming, however, requires care,
    expertise, and wisdom. A small bug in a computer-aided design program, for
    example, can lead to the catastrophic collapse of an airplane or a dam or
    the self-destruction of an industrial robot.
  </p>
  <p>
    Master software engineers have the ability to organize programs so that
    they can be reasonably sure that the resulting processes will perform the
    tasks intended. They can visualize the behavior of their systems in
    advance. They know how to structure programs so that unanticipated problems
    do not lead to catastrophic consequences, and when problems do arise, they
    can <em>debug</em> their programs. Well-designed computational systems,
    like well-designed automobiles or nuclear reactors, are designed in a
    modular manner, so that the parts can be constructed, replaced, and
    debugged separately.
  </p>
  <h5>Programming in Lisp</h5>
  <p>
    We need an appropriate language for describing processes, and we will use
    for this purpose the programming language Lisp. Just as our everyday
    thoughts are usually expressed in our natural language (such as English,
    French, or Japanese), and descriptions of quantitative phenomena are
    expressed with mathematical notations, our procedural thoughts will be
    expressed in Lisp. Lisp was invented in the late 1950s as a formalism for
    reasoning about the use of certain kinds of logical expressions, called
    recursion equations, as a model for computation. The language was conceived
    by John McCarthy and is based on his paper “Recursive Functions of Symbolic
    Expressions and Their Computation by Machine” (McCarthy 1960).
  </p>
  <p>
    Despite its inception as a mathematical formalism, Lisp is a practical
    programming language. A Lisp interpreter is a machine that carries out
    processes described in the Lisp language. The first Lisp interpreter was
    implemented by McCarthy with the help of colleagues and students in the
    Artificial Intelligence Group of the MIT Research Laboratory of Electronics
    and in the MIT Computation Center.<sup id="r1.1s"><a href="#r1.1d"
    >1</a></sup> Lisp, whose name is an acronym for LISt Processing, was
    designed to provide symbol-manipulating capabilities for attacking
    programming problems such as the symbolic differentiation and integration
    of algebraic expressions. It included for this purpose new data objects
    known as atoms and lists, which most strikingly set it apart from all other
    languages of the period.
  </p>
  <p>
    Lisp was not the product of a concerted design effort. Instead, it evolved
    informally in an experimental manner in response to users’ needs and to
    pragmatic implementation considerations. Lisp’s informal evolution has
    continued through the years, and the community of Lisp users has
    traditionally resisted attempts to promulgate any “official” definition of
    the language. This evolution, together with the flexibility and elegance of
    the initial conception, has enabled Lisp, which is the second oldest
    language in widespread use today (only Fortran is older), to continually
    adapt to encompass the most modern ideas about program design. Thus, Lisp
    is by now a family of dialects, which, while sharing most of the original
    features, may differ from one another in significant ways. The dialect of
    Lisp used in this book is called Scheme.<sup id="r1.2s"><a href="#r1.2d"
    >2</a></sup>
  </p>
  <p>
    Because of its experimental character and its emphasis on symbol
    manipulation, Lisp was at first very inefficient for numerical
    computations, at least in comparison with Fortran. Over the years, however,
    Lisp compilers have been developed that translate programs into machine
    code that can perform numerical computations reasonably efficiently. And
    for special applications, Lisp has been used with great effectiveness.<sup
    id="r1.3s"><a href="#r1.3d">3</a></sup> Although Lisp has not yet overcome
    its old reputation as hopelessly inefficient, Lisp is now used in many
    applications where efficiency is not the central concern. For example, Lisp
    has become a language of choice for operating-system shell languages and
    for extension languages for editors and computer-aided design systems.
  </p>
  <p>
    If Lisp is not a mainstream language, why are we using it as the framework
    for our discussion of programming? Because the language possesses unique
    features that make it an excellent medium for studying important
    programming constructs and data structures and for relating them to the
    linguistic features that support them. The most significant of these
    features is the fact that Lisp descriptions of processes, called
    procedures, can themselves be represented and manipulated as Lisp data. The
    importance of this is that there are powerful program-design techniques
    that rely on the ability to blur the traditional distinction between
    “passive” data and “active” processes. As we shall discover, Lisp’s
    flexibility in handling procedures as data makes it one of the most
    convenient languages in existence for exploring these techniques. The
    ability to represent procedures as data also makes Lisp an excellent
    language for writing programs that must manipulate other programs as data,
    such as the interpreters and compilers that support computer languages.
    Above and beyond these considerations, programming in Lisp is great fun.
  </p>
  <hr>
  <footer>
    <p>
      <sup id="r1.1d"><a href="#r1.1s">1</a></sup> The <em>Lisp 1 Programmer’s
      Manual</em> appeared in 1960, and the <em>Lisp 1.5 Programmer’s
      Manual</em> (McCarthy 1965) was published in 1962. The early history of
      Lisp is described in McCarthy 1978.
    </p>
    <p>
      <sup id="r1.2d"><a href="#r1.2s">2</a></sup> The two dialects in which
      most major Lisp programs of the 1970s were written are MacLisp (Moon
      1978; Pitman 1983), developed at the MIT Project MAC, and Interlisp
      (Teitelman 1974), developed at Bolt Beranek and Newman Inc. and the Xerox
      Palo Alto Research Center. Portable Standard Lisp (Hearn 1969; Griss
      1981) was a Lisp dialect designed to be easily portable between different
      machines. MacLisp spawned a number of subdialects, such as Franz Lisp,
      which was developed at the University of California at Berkeley, and
      Zetalisp (Moon 1981), which was based on a special-purpose processor
      designed at the MIT Artificial Intelligence Laboratory to run Lisp very
      efficiently. The Lisp dialect used in this book, called Scheme (Steele
      1975), was invented in 1975 by Guy Lewis Steele Jr. and Gerald Jay
      Sussman of the MIT Artificial Intelligence Laboratory and later
      reimplemented for instructional use at MIT. Scheme became an IEEE
      standard in 1990 (IEEE 1990). The Common Lisp dialect (Steele 1982,
      Steele 1990) was developed by the Lisp community to combine features from
      the earlier Lisp dialects to make an industrial standard for Lisp. Common
      Lisp became an ANSI standard in 1994 (ANSI 1994).
    </p>
    <p>
      <sup id="r1.3d"><a href="#r1.3s">3</a></sup> One such special application
      was a breakthrough computation of scientific importance—an integration of
      the motion of the Solar System that extended previous results by nearly
      two orders of magnitude, and demonstrated that the dynamics of the Solar
      System is chaotic. This computation was made possible by new integration
      algorithms, a special-purpose compiler, and a special-purpose computer
      all implemented with the aid of software tools written in Lisp (Abelson
      et al. 1992; Sussman and Wisdom 1992).
    </p>
  </footer>
</section>

<section id="s1.1">
<section id="s1.1.0">
  <h3><a href="#s1.1">1.1 The Elements of Programming</a></h3>
  <p>
    A powerful programming language is more than just a means for instructing a
    computer to perform tasks. The language also serves as a framework within
    which we organize our ideas about processes. Thus, when we describe a
    language, we should pay particular attention to the means that the language
    provides for combining simple ideas to form more complex ideas. Every
    powerful language has three mechanisms for accomplishing this:
  </p>
  <ul>
    <li>
      <em>primitive expressions</em>, which represent the simplest entities the
      language is concerned with,
    </li>
    <li>
      <em>means of combination</em>, by which compound elements are built from
      simpler ones, and
    </li>
    <li>
      <em>means of abstraction</em>, by which compound elements can be named
      and manipulated as units.
    </li>
  </ul>
    In programming, we deal with two kinds of elements: procedures and data.
    (Later we will discover that they are really not so distinct.) Informally,
    data is “stuff” that we want to manipulate, and procedures are descriptions
    of the rules for manipulating the data. Thus, any powerful programming
    language should be able to describe primitive data and primitive procedures
    and should have methods for combining and abstracting procedures and data.
  </p>
  <p>
    In this chapter we will deal only with simple numerical data so that we can
    focus on the rules for building procedures.<sup id="r1.4s"><a href="#r1.4d"
    >4</a></sup> In later chapters we will see that these same rules allow us
    to build procedures to manipulate compound data as well.
  </p>
</section>

<section id="s1.1.1">
  <h4><a href="#s1.1.1">1.1.1 Expressions</a></h4>
  <p>
    One easy way to get started at programming is to examine some typical
    interactions with an interpreter for the Scheme dialect of Lisp. Imagine
    that you are sitting at a computer terminal. You type an
    <em>expression</em>, and the interpreter responds by displaying the result
    of its evaluating that expression.
  </p>
  <p>
    One kind of primitive expression you might type is a number. (More
    precisely, the expression that you type consists of the numerals that
    represent the number in base 10.) If you present Lisp with a number
  </p>
  <textarea name="1.1.1-01">486</textarea>
  <p>
    the interpreter will respond by printing<sup id="r1.5s"><a href="#r1.5d"
    >5</a></sup>
  </p>
  <output for="1.1.1-01" class="block">486</output>
  <p>
    Expressions representing numbers may be combined with an expression
    representing a primitive procedure (such as <code>+</code> or
    <code>*</code>) to form a compound expression that represents the
    application of the procedure to those numbers. For example:
  </p>
  <textarea name="1.1.1-02" rows="5">
(+ 137 349)
(- 1000 334)
(* 5 99)
(/ 10 5)
(+ 2.7 10)</textarea>
  <output for="1.1.1-02" class="block">486
666
495
2
12.7</output>
  <p>
    Expressions such as these, formed by delimiting a list of expressions
    within parentheses in order to denote procedure application, are called
    <em>combinations</em>. The leftmost element in the list is called the
    <em>operator</em>, and the other elements are called <em>operands</em>. The
    value of a combination is obtained by applying the procedure specified by
    the operator to the <em>arguments</em> that are the values of the operands.
  </p>
  <p>
    The convention of placing the operator to the left of the operands is known
    as <em>prefix notation</em>, and it may be somewhat confusing at first
    because it departs significantly from the customary mathematical
    convention. Prefix notation has several advantages, however. One of them is
    that it can accommodate procedures that may take an arbitrary number of
    arguments, as in the following examples:
</p>
  <textarea name="1.1.1-03" rows="2">
(+ 21 35 12 7)
(* 25 4 12)</textarea>
  <output for="1.1.1-03" class="block">75
1200</output>
  <p>
    No ambiguity can arise, because the operator is always the leftmost element
    and the entire combination is delimited by the parentheses.
  </p>
  <p>
    A second advantage of prefix notation is that it extends in a
    straightforward way to allow combinations to be <em>nested</em>, that is,
    to have combinations whose elements are themselves combinations:
  </p>
  <textarea name="1.1.1-04">
(+ (* 3 5) (- 10 6))</textarea>
  <output for="1.1.1-04" class="block">19</output>
  <p>
    There is no limit (in principle) to the depth of such nesting and to the
    overall complexity of the expressions that the Lisp interpreter can
    evaluate. It is we humans who get confused by still relatively simple
    expressions such as
  </p>
  <textarea name="1.1.1-05">
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))</textarea>
  <p>
    which the interpreter would readily evaluate to be <output for="1.1.1-05"
    >57</output>. We can help ourselves by writing such an expression in the
    form
  </p>
  <textarea name="1.1.1-06" rows="5">
(+ (* 3
      (+ (* 2 4)
          (+ 3 5)))
   (+ (- 10 7)
      6))</textarea>
  <output for="1.1.1-06" class="block">57</output>
  <p>
    following a formatting convention known as <em>pretty-printing</em>, in
    which each long combination is written so that the operands are aligned
    vertically. The resulting indentations display clearly the structure of the
    expression.<sup id="r1.6s"><a href="#r1.6d">6</a></sup>
  </p>
  <p>
    Even with complex expressions, the interpreter always operates in the same
    basic cycle: It reads an expression from the terminal, evaluates the
    expression, and prints the result. This mode of operation is often
    expressed by saying that the interpreter runs in a <em>read-eval-print</em>
    loop. Observe in particular that it is not necessary to explicitly instruct
    the interpreter to print the value of the expression.<sup id="r1.7s"><a
    href="#r1.7d">7</a></sup>
  </p>
</section>

<section id="s1.1.2">
  <h4><a href="#s1.1.2">1.1.2 Naming and the Environment</a></h4>
  <p>
    A critical aspect of a programming language is the means it provides for
    using names to refer to computational objects. We say that the name
    identifies a <em>variable</em> whose <em>value</em> is the object.
  </p>
  <p>
    In the Scheme dialect of Lisp, we name things with <code>define</code>.
    Typing
  </p>
  <textarea name="1.1.2-01">(define size 2)</textarea>
  <output for="1.1.2-01" class="block">size</output>
  <p>
    causes the interpreter to associate the value <code>2</code> with the name
    <code>size</code>.<sup id="r1.8s"><a href="#r1.8d">8</a></sup> Once the
    name <code>size</code> has been associated with the number <code>2</code>,
    we can refer to the value <code>2</code> by name:
  </p>
  <textarea name="1.1.2-02" data-extends="1.1.2-01" rows="2">
size
(* 5 size)</textarea>
  <output for="1.1.2-02" class="block">2
10</output>
  <p>
    Here are further examples of the use of <code>define</code>:
  </p>
  <textarea name="1.1.2-03" rows="5">
(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))
(define circumference (* 2 pi radius))
circumference</textarea>
  <output for="1.1.2-03" class="block">pi
radius
314.159
circumference
62.8318</output>
  <p>
    <code>Define</code> is our language’s simplest means of abstraction, for it
    allows us to use simple names to refer to the results of compound
    operations, such as the <code>circumference</code> computed above. In
    general, computational objects may have very complex structures, and it
    would be extremely inconvenient to have to remember and repeat their
    details each time we want to use them. Indeed, complex programs are
    constructed by building, step by step, computational objects of increasing
    complexity. The interpreter makes this step-by-step program construction
    particularly convenient because name-object associations can be created
    incrementally in successive interactions. This feature encourages the
    incremental development and testing of programs and is largely responsible
    for the fact that a Lisp program usually consists of a large number of
    relatively simple procedures.
  </p>
  <p>
    It should be clear that the possibility of associating values with symbols
    and later retrieving them means that the interpreter must maintain some
    sort of memory that keeps track of the name-object pairs. This memory is
    called the <code>environment</code> (more precisely the <code>global
    environment</code>, since we will see later that a computation may involve
    a number of different environments).<sup id="r1.9s"><a href="#r1.9d"
    >9</a></sup>
  </p>
</section>

<section id="s1.1.3">
  <h4><a href="#s1.1.3">1.1.3 Evaluating Combinations</a></h4>
  <p>
    One of our goals in this chapter is to isolate issues about thinking
    procedurally. As a case in point, let us consider that, in evaluating
    combinations, the interpreter is itself following a procedure.
  </p>
  <ul>
    <li>
      To evaluate a combination, do the following:
      <ol>
        <li>
          Evaluate the subexpressions of the combination.
        </li>
        <li>
          Apply the procedure that is the value of the leftmost subexpression
          (the operator) to the arguments that are the values of the other
          subexpressions (the operands).
        </li>
      </ol>
    </li>
  </ul>
  <p>
    Even this simple rule illustrates some important points about processes in
    general. First, observe that the first step dictates that in order to
    accomplish the evaluation process for a combination we must first perform
    the evaluation process on each element of the combination. Thus, the
    evaluation rule is <em>recursive</em> in nature; that is, it includes, as
    one of its steps, the need to invoke the rule itself.<sup id="r1.10s"><a
    href="#r1.10d">10</a></sup>
  </p>
  <p>
    Notice how succinctly the idea of recursion can be used to express what, in
    the case of a deeply nested combination, would otherwise be viewed as a
    rather complicated process. For example, evaluating
  </p>
  <textarea name="1.1.3-01" rows="2">
(* (+ 2 (* 4 6))
   (+ 3 5 7))</textarea>
  <output for="1.1.3-01" class="block">390</output>
  <p>
    requires that the evaluation rule be applied to four different
    combinations. We can obtain a picture of this process by representing the
    combination in the form of a tree, as shown in figure <a href="#f1.1"
    >1.1</a>. Each combination is represented by a node with branches
    corresponding to the operator and the operands of the combination stemming
    from it. The terminal nodes (that is, nodes with no branches stemming from
    them) represent either operators or numbers. Viewing evaluation in terms of
    the tree, we can imagine that the values of the operands percolate upward,
    starting from the terminal nodes and then combining at higher and higher
    levels. In general, we shall see that recursion is a very powerful
    technique for dealing with hierarchical, treelike objects. In fact, the
    “percolate values upward” form of the evaluation rule is an example of a
    general kind of process known as <em>tree accumulation</em>.
  </p>
  <figure id="f1.1">
    <img alt="Figure 1.1: Tree representation" src="./img/f1.1.gif">
    <figcaption>
      Figure 1.1: Tree representation, showing the value of each
      subcombination.
    </figcaption>
  </figure>
  <p>
    Next, observe that the repeated application of the first step brings us to
    the point where we need to evaluate, not combinations, but primitive
    expressions such as numerals, built-in operators, or other names. We take
    care of the primitive cases by stipulating that
  </p>
  <ul>
    <li>
      the values of numerals are the numbers that they name,
    </li>
    <li>
      the values of built-in operators are the machine instruction sequences
      that carry out the corresponding operations, and
    </li>
    <li>
      the values of other names are the objects associated with those names in
      the environment.
    </li>
  </ul>
  <p>
    We may regard the second rule as a special case of the third one by
    stipulating that symbols such as <code>+</code> and <code>*</code> are also
    included in the global environment, and are associated with the sequences
    of machine instructions that are their “values.” The key point to notice is
    the role of the environment in determining the meaning of the symbols in
    expressions. In an interactive language such as Lisp, it is meaningless to
    speak of the value of an expression such as <code>(+&nbsp;x&nbsp;1)</code>
    without specifying any information about the environment that would provide
    a meaning for the symbol <code>x</code> (or even for the symbol
    <code>+</code>). As we shall see in chapter 3, the general notion of the
    environment as providing a context in which evaluation takes place will
    play an important role in our understanding of program execution.
  </p>
  <p>
    Notice that the evaluation rule given above does not handle definitions.
    For instance, evaluating <code>(define&nbsp;x&nbsp;3)</code> does not apply
    <code>define</code> to two arguments, one of which is the value of the
    symbol <code>x</code> and the other of which is <code>3</code>, since the
    purpose of the <code>define</code> is precisely to associate <code>x</code>
    with a value. (That is, <code>(define&nbsp;x&nbsp;3)</code> is not a
    combination.)
  </p>
  <p>
    Such exceptions to the general evaluation rule are called <em>special
    forms</em>. <code>Define</code> is the only example of a special form that
    we have seen so far, but we will meet others shortly. Each special form has
    its own evaluation rule. The various kinds of expressions (each with its
    associated evaluation rule) constitute the syntax of the programming
    language. In comparison with most other programming languages, Lisp has a
    very simple syntax; that is, the evaluation rule for expressions can be
    described by a simple general rule together with specialized rules for a
    small number of special forms.<sup id="r1.11s"><a href="#r1.11d"
    >11</a></sup>
  </p>
</section>

<section id="s1.1.4">
  <h4><a href="#s1.1.4">1.1.4 Compound Procedures</a></h4>
  <p>
    We have identified in Lisp some of the elements that must appear in any
    powerful programming language:
  </p>
  <ul>
    <li>
      Numbers and arithmetic operations are primitive data and procedures.
    </li>
    <li>
      Nesting of combinations provides a means of combining operations.
    </li>
    <li>
      Definitions that associate names with values provide a limited means of
      abstraction.
    </li>
  </ul>
  <p>
    Now we will learn about <em>procedure definitions</em>, a much more
    powerful abstraction technique by which a compound operation can be given a
    name and then referred to as a unit.
  </p>
  <p>
    We begin by examining how to express the idea of “squaring.” We might say,
    “To square something, multiply it by itself.” This is expressed in our
    language as
  </p>
  <textarea name="1.1.4-01">(define (square x) (* x x))</textarea>
  <p>
    We can understand this in the following way:
  </p>
<pre><code>(define (square  x)        (*         x     x))
 ↑         ↑     ↑          ↑         ↑     ↑
To      square something, multiply   it by itself.</code></pre>
  <p>
    We have here a <em>compound procedure</em>, which has been given the name
    <code>square</code>. The procedure represents the operation of multiplying
    something by itself. The thing to be multiplied is given a local name,
    <code>x</code>, which plays the same role that a pronoun plays in natural
    language. Evaluating the definition creates this compound procedure and
    associates it with the name square.<sup id="r1.12s"><a href="#r1.12d"
    >12</a></sup>
  </p>
  <p>
    The general form of a procedure definition is
  </p>
  <pre><code>(define (<em>&lt;name&gt;</em> <em>&lt;formal parameters&gt;</em
    >) <em>&lt;body&gt;</em>)</code></pre>
  <p>
    The <code><em>&lt;name&gt;</em></code> is a symbol to be associated with
    the procedure definition in the environment.<sup id="r1.13s"><a
    href="#r1.13d">13</a></sup> The <code><em>&lt;formal parameters&gt;</em
    ></code> are the names used within the body of the procedure to refer to
    the corresponding arguments of the procedure. The <code><em
    >&lt;body&gt;</em></code> is an expression that will yield the value of the
    procedure application when the formal parameters are replaced by the actual
    arguments to which the procedure is applied.<sup id="r1.14s"><a
    href="#r1.14d">14</a></sup> The <code><em>&lt;name&gt;</em></code> and the
    <code><em>&lt;formal parameters&gt;</em></code> are grouped within
    parentheses, just as they would be in an actual call to the procedure being
    defined.
  </p>
  <p>
    Having defined square, we can now use it:
  </p>
  <textarea name="1.1.4-02" data-extends="1.1.4-01" rows="3">
(square 21)
(square (+ 2 5))
(square (square 3))</textarea>
  <output for="1.1.4-02" class="block">441
49
81</output>
  <p>
    We can also use <code>square</code> as a building block in defining other
    procedures. For example, <code>x<sup>2</sup> + y<sup>2</sup></code> can be
    expressed as
  </p>
  <pre><code>(+ (square x) (square y))</code></pre>
  <p>
    We can easily define a procedure <code>sum-of-squares</code> that, given
    any two numbers as arguments, produces the sum of their squares:
  </p>
  <textarea name="1.1.4-03" data-extends="1.1.4-01" rows="4">
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)</textarea>
  <output for="1.1.4-03" class="block">sum-of-squares
25</output>
  <p>
    Now we can use <code>sum-of-squares</code> as a building block in
    constructing further procedures:
  </p>
  <textarea name="1.1.4-04" data-extends="1.1.4-01 1.1.4-03" rows="4">
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)</textarea>
  <output for="1.1.4-04" class="block">f
136</output>
  <p>
    Compound procedures are used in exactly the same way as primitive
    procedures. Indeed, one could not tell by looking at the definition of
    <code>sum-of-squares</code> given above whether square was built into the
    interpreter, like <code>+</code> and <code>*</code>, or defined as a
    compound procedure.
  </p>
</section>

<section id="s1.1.5">
  <h4><a href="#s1.1.5">1.1.5 The Substitution Model for Procedure
    Application</a></h4>
  <p>
    To evaluate a combination whose operator names a compound procedure, the
    interpreter follows much the same process as for combinations whose
    operators name primitive procedures, which we described in section
    <a href="#s1.1.3">1.1.3</a>. That is, the interpreter evaluates the
    elements of the combination and applies the procedure (which is the value
    of the operator of the combination) to the arguments (which are the values
    of the operands of the combination).
  </p>
  <p>
    We can assume that the mechanism for applying primitive procedures to
    arguments is built into the interpreter. For compound procedures, the
    application process is as follows:
  </p>
  <ul>
    <li>
      To apply a compound procedure to arguments, evaluate the body of the
      procedure with each formal parameter replaced by the corresponding
      argument.
    </li>
  </ul>
  <p>
    To illustrate this process, let’s evaluate the combination
  </p>
  <pre><code>(f 5)</code></pre>
  <p>
    where <code>f</code> is the procedure defined in section <a href="#s1.1.4"
    >1.1.4</a>. We begin by retrieving the body of <code>f</code>:
  </p>
  <pre><code>(sum-of-squares (+ a 1) (* a 2))</code></pre>
  <p>
    Then we replace the formal parameter <code>a</code> by the argument
    <code>5</code>:
  </p>
  <pre><code>(sum-of-squares (+ 5 1) (* 5 2))</code></pre>
  <p>
    Thus the problem reduces to the evaluation of a combination with two
    operands and an operator <code>sum-of-squares</code>. Evaluating this
    combination involves three subproblems. We must evaluate the operator to
    get the procedure to be applied, and we must evaluate the operands to get
    the arguments. Now <code>(+&nbsp;5&nbsp;1)</code> produces <code>6</code>
    and <code>(*&nbsp;5&nbsp;2)</code> produces <code>10</code>, so we must
    apply the <code>sum-of-squares</code> procedure to <code>6</code> and
    <code>10</code>. These values are substituted for the formal parameters
    <code>x</code> and <code>y</code> in the body of
    <code>sum-of-squares</code>, reducing the expression to
  </p>
  <pre><code>(+ (square 6) (square 10))</code></pre>
  <p>
    If we use the definition of <code>square</code>, this reduces to
  </p>
  <pre><code>(+ (* 6 6) (* 10 10))</code></pre>
  <p>
    which reduces by multiplication to
  </p>
  <pre><code>(+ 36 100)</code></pre>
  <p>
    and finally to
  </p>
  <pre><code>136</code></pre>
  <p>
    The process we have just described is called the <em>substitution
    model</em> for procedure application. It can be taken as a model that
    determines the “meaning” of procedure application, insofar as the
    procedures in this chapter are concerned. However, there are two points
    that should be stressed:
  </p>
  <ul>
    <li>
      The purpose of the substitution is to help us think about procedure
      application, not to provide a description of how the interpreter really
      works. Typical interpreters do not evaluate procedure applications by
      manipulating the text of a procedure to substitute values for the formal
      parameters. In practice, the “substitution” is accomplished by using a
      local environment for the formal parameters. We will discuss this more
      fully in chapters 3 and 4 when we examine the implementation of an
      interpreter in detail.
    </li>
    <li>
      Over the course of this book, we will present a sequence of increasingly
      elaborate models of how interpreters work, culminating with a complete
      implementation of an interpreter and compiler in chapter 5. The
      substitution model is only the first of these models—a way to get started
      thinking formally about the evaluation process. In general, when modeling
      phenomena in science and engineering, we begin with simplified,
      incomplete models. As we examine things in greater detail, these simple
      models become inadequate and must be replaced by more refined models. The
      substitution model is no exception. In particular, when we address in
      chapter 3 the use of procedures with “mutable data,” we will see that the
      substitution model breaks down and must be replaced by a more complicated
      model of procedure application.<sup id="r1.15s"><a href="#r1.15d"
      >15</a></sup>
    </li>
  </ul>
  <h5>Applicative order versus normal order</h5>
  <p>
    According to the description of evaluation given in section <a
    href="#s1.1.3">1.1.3</a>, the interpreter first evaluates the operator and
    operands and then applies the resulting procedure to the resulting
    arguments. This is not the only way to perform evaluation. An alternative
    evaluation model would not evaluate the operands until their values were
    needed. Instead it would first substitute operand expressions for
    parameters until it obtained an expression involving only primitive
    operators, and would then perform the evaluation. If we used this method,
    the evaluation of
  </p>
  <pre><code>(f 5)</code></pre>
  <p>
    would proceed according to the sequence of expansions
  </p>
  <pre><code>(sum-of-squares (+ 5 1) (* 5 2))

(+    (square (+ 5 1))      (square (* 5 2))  )

(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))</code></pre>
  <p>
    followed by the reductions
  </p>
  <pre><code>(+         (* 6 6)             (* 10 10))

(+           36                   100)
                    136</code></pre>
  <p>
    This gives the same answer as our previous evaluation model, but the
    process is different. In particular, the evaluations of <code
    >(+&nbsp;5&nbsp;1)</code> and <code>(*&nbsp;5&nbsp;2)</code> are each
    performed twice here, corresponding to the reduction of the expression
  </p>
  <pre><code>(* x x)</code></pre>
  <p>
    with <code>x</code> replaced respectively by <code>(+&nbsp;5&nbsp;1)</code>
    and <code>(*&nbsp;5&nbsp;2)</code>.
  </p>
  <p>
    This alternative “fully expand and then reduce” evaluation method is known
    as <em>normal-order evaluation</em>, in contrast to the “evaluate the
    arguments and then apply” method that the interpreter actually uses, which
    is called applicative-order evaluation. It can be shown that, for procedure
    applications that can be modeled using substitution (including all the
    procedures in the first two chapters of this book) and that yield
    legitimate values, normal-order and applicative-order evaluation produce
    the same value. (See exercise <a href="#e1.5">1.5</a> for an instance of an
    “illegitimate” value where normal-order and applicative-order evaluation do
    not give the same result.)
  </p>
  <p>
    Lisp uses applicative-order evaluation, partly because of the additional
    efficiency obtained from avoiding multiple evaluations of expressions such
    as those illustrated with <code>(+&nbsp;5&nbsp;1)</code> and <code
    >(*&nbsp;5&nbsp;2)</code> above and, more significantly, because
    normal-order evaluation becomes much more complicated to deal with when we
    leave the realm of procedures that can be modeled by substitution. On the
    other hand, normal-order evaluation can be an extremely valuable tool, and
    we will investigate some of its implications in chapters 3 and 4.<sup
    id="r1.16s"><a href="#r1.16d">16</a></sup>
  </p>
</section>

<section id="s1.1.6">
  <h4><a href="#s1.1.6">1.1.6 Conditional Expressions and Predicates</a></h4>
  <p>
    The expressive power of the class of procedures that we can define at this
    point is very limited, because we have no way to make tests and to perform
    different operations depending on the result of a test. For instance, we
    cannot define a procedure that computes the absolute value of a number by
    testing whether the number is positive, negative, or zero and taking
    different actions in the different cases according to the rule
  </p>
  <figure>
    <math>
      <mrow>
        <mrow>
          <mo>|</mo>
          <mi>x</mi>
          <mo>|</mo>
        </mrow>
        <mo>=</mo>
        <mo>&lbrace;</mo>
        <mtable>
          <mtr>
            <mtd><mi>x</mi></mtd>
            <mtd><mtext>if&nbsp;</mtext><mi>x</mi><mo>&gt;</mo><mn>0</mn></mtd>
          </mtr>
          <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mtext>if&nbsp;</mtext><mi>x</mi><mo>=</mo><mn>0</mn></mtd>
          </mtr>
          <mtr>
            <mtd><mo>-</mo><mi>x</mi></mtd>
            <mtd><mtext>if&nbsp;</mtext><mi>x</mi><mo>&lt;</mo><mn>0</mn></mtd>
          </mtr>
        </mtable>
      </mrow>
    </math>
  </figure>
  <p>
    This construct is called a <em>case analysis</em>, and there is a special
    form in Lisp for notating such a case analysis. It is called
    <code>cond</code> (which stands for “conditional”), and it is used as
    follows:
  </p>
  <textarea name="1.1.6-01" rows="4">
(define (abs x)
  (cond ((&gt; x 0) x)
        ((= x 0) 0)
        ((&lt; x 0) (- x))))</textarea>
  <output for="1.1.6-01" class="block">abs</output>
  <p>
    The general form of a conditional expression is
  </p>
  <pre><code>(cond (<em>&lt;p1&gt;</em> <em>&lt;e1&gt;</em>)
      (<em>&lt;p2&gt;</em> <em>&lt;e2&gt;</em>)
      ⋮
      (<em>&lt;pn&gt;</em> <em>&lt;en&gt;</em>))</code></pre>
  <p>
    consisting of the symbol <code>cond</code> followed by parenthesized pairs
    of expressions (<code><em>&lt;p&gt;</em> <em>&lt;e&gt;</em></code>) called
    clauses. The first expression in each pair is a <em>predicate</em>—that is,
    an expression whose value is interpreted as either true or false.<sup
    id="r1.17s"><a href="#r1.17d">17</a></sup>
  </p>
  <p>
    Conditional expressions are evaluated as follows. The predicate
    <code><em>&lt;p1&gt;</em></code> is evaluated first. If its value is false,
    then <code><em>&lt;p2&gt;</em></code> is evaluated. If <code><em
    >&lt;p2&gt;</em></code>’s value is also false, then <code><em
    >&lt;p3&gt;</em></code> is evaluated. This process continues until a
    predicate is found whose value is true, in which case the interpreter
    returns the value of the corresponding <em>consequent expression</em>
    <code><em>&lt;e&gt;</em></code> of the clause as the value of the
    conditional expression. If none of the <code><em>&lt;p&gt;</em></code>’s is
    found to be true, the value of the cond is undefined.
  </p>
  <p>
    The word <em>predicate</em> is used for procedures that return true or
    false, as well as for expressions that evaluate to true or false. The
    absolute-value procedure <code>abs</code> makes use of the primitive
    predicates <code>&gt;</code>, <code>&lt;</code>, and <code>=</code>.<sup
    id="r1.18s"><a href="#r1.18d">18</a></sup> These take two numbers as
    arguments and test whether the first number is, respectively, greater than,
    less than, or equal to the second number, returning true or false
    accordingly.
  </p>
  <p>
    Another way to write the absolute-value procedure is
  </p>
  <textarea name="1.1.6-02" rows="3">
(define (abs x)
  (cond ((&lt; x 0) (- x))
        (else x)))</textarea>
  <output for="1.1.6-02" class="block">abs</output>
  <p>
    which could be expressed in English as “If <code>x</code> is less than zero
    return <code>-&nbsp;x</code>; otherwise return <code>x</code>.”
    <code>Else</code> is a special symbol that can be used in place of the
    <code><em>&lt;p&gt;</em></code> in the final clause of a <code>cond</code>.
    This causes the <code>cond</code> to return as its value the value of the
    corresponding <code><em>&lt;e&gt;</em></code> whenever all previous clauses
    have been bypassed. In fact, any expression that always evaluates to a true
    value could be used as the <code><em>&lt;p&gt;</em></code> here.
  </p>
  <p>
    Here is yet another way to write the absolute-value procedure:
  </p>
  <textarea name="1.1.6-03" rows="4">
(define (abs x)
  (if (&lt; x 0)
      (- x)
      x))</textarea>
  <output for="1.1.6-03" class="block">abs</output>
  <p>
    This uses the special form <code>if</code>, a restricted type of
    conditional that can be used when there are precisely two cases in the
    case analysis. The general form of an <code>if</code> expression is
  </p>
  <pre><code>(if <em>&lt;predicate&gt;</em> <em>&lt;consequent&gt;</em> <em
    >&lt;alternative&gt;</em>)</code></pre>
  <p>
    To evaluate an <code>if</code> expression, the interpreter starts by
    evaluating the <code><em>&lt;predicate&gt;</em></code> part of the
    expression. If the <code><em>&lt;predicate&gt;</em></code> evaluates to a
    true value, the interpreter then evaluates the <code><em
    >&lt;consequent&gt;</em></code> and returns its value. Otherwise it
    evaluates the <code><em>&lt;alternative&gt;</em></code> and returns its
    value.<sup id="r1.19s"><a href="#r1.19d">19</a></sup>
  </p>
  <p>
    In addition to primitive predicates such as <code>&lt;</code>,
    <code>=</code>, and <code>&gt;</code>, there are logical composition
    operations, which enable us to construct compound predicates.
    The three most frequently used are these:
  </p>
  <ul>
    <li>
      <code>(and <em>&lt;e1&gt;</em> ... <em>&lt;en&gt;</em>)</code> <br>
      The interpreter evaluates the expressions <code><em>&lt;e&gt;</em></code>
      one at a time, in left-to-right order. If any <code><em>&lt;e&gt;</em
      ></code> evaluates to false, the value of the <code>and</code> expression
      is false, and the rest of the <code><em>&lt;e&gt;</em></code>’s are not
      evaluated. If all <code><em>&lt;e&gt;</em></code>’s evaluate to true
      values, the value of the <code>and</code> expression is the value of the
      last one.
    </li>
    <li>
      <code>(or <em>&lt;e1&gt;</em> ... <em>&lt;en&gt;</em>)</code> <br>
      The interpreter evaluates the expressions <code><em>&lt;e&gt;</em></code>
      one at a time, in left-to-right order. If any <code><em>&lt;e&gt;</em
      ></code> evaluates to a true value, that value is returned as the value
      of the <code>or</code> expression, and the rest of the <code><em
      >&lt;e&gt;</em></code>’s are not evaluated. If all <code><em
      >&lt;e&gt;</em></code>’s evaluate to false, the value of the
      <code>or</code> expression is false.
    </li>
    <li>
      <code>(not <em>&lt;e&gt;</em>)</code> <br>
      The value of a <code>not</code> expression is true when the expression
      <code><em>&lt;e&gt;</em></code> evaluates to false, and false otherwise.
    </li>
  </ul>
  <p>
    Notice that <code>and</code> and <code>or</code> are special forms, not
    procedures, because the subexpressions are not necessarily all evaluated.
    <code>Not</code> is an ordinary procedure.
  </p>
  <p>
    As an example of how these are used, the condition that a number
    <code>x</code> be in the range <code>5 &lt; x &lt; 10</code> may be
    expressed as
  </p>
  <pre><code>(and (&gt; x 5) (&lt; x 10))</code></pre>
  <p>
    As another example, we can define a predicate to test whether one number is
    greater than or equal to another as
  </p>
  <textarea name="1.1.6-04" rows="2">
(define (&gt;= x y)
  (or (&gt; x y) (= x y)))</textarea>
  <output for="1.1.6-04" class="block">&gt;=</output>
  <p>
    or alternatively as
  </p>
  <textarea name="1.1.6-05" rows="2">
(define (&gt;= x y)
  (not (&lt; x y)))</textarea>
  <output for="1.1.6-05" class="block">&gt;=</output>
</section>

<section id="e1.1">
  <h5><a href="#e1.1">Exercise 1.1</a></h5>
  <p>
    Below is a sequence of expressions. What is the result printed by the
    interpreter in response to each expression? Assume that the sequence is to
    be evaluated in the order in which it is presented.
  </p>
  <textarea name="e1.1-01" rows="20">
10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a)
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
(+ 2 (if (&gt; b a) b a))
(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))</textarea>
  <output for="e1.1-01" class="block">&ZeroWidthSpace;</output>
</section>

<section id="e1.2">
  <h5><a href="#e1.2">Exercise 1.2</a></h5>
  <p>
    Translate the following expression into prefix form
  </p>
  <figure>
    <math>
      <mfrac>
        <mrow>
          <mn>5</mn><mo>+</mo><mn>4</mn><mo>+</mo>
          <mo>&lpar;</mo><mn>2</mn><mo>-</mo>
            <mo>&lpar;</mo><mn>3</mn><mo>-</mo>
              <mo>&lpar;</mo><mn>6</mn><mo>+</mo>
                <mfrac><mn>4</mn><mn>5</mn></mfrac>
              <mo>&rpar;</mo>
            <mo>&rpar;</mo>
          <mo>&rpar;</mo>
        </mrow>
        <mrow>
          <mn>3</mn>
          <mo>&lpar;</mo><mn>6</mn><mo>-</mo><mn>2</mn><mo>&rpar;</mo>
          <mo>&lpar;</mo><mn>2</mn><mo>-</mo><mn>7</mn><mo>&rpar;</mo>
        </mrow>
      </mfrac>
    </math>
  </figure>
  <textarea name="e1.2-01"></textarea>
  <output for="e1.2-01" class="block">&ZeroWidthSpace;</output>
</section>

<section id="e1.3">
  <h5><a href="#e1.3">Exercise 1.3</a></h5>
  <p>
    Define a procedure that takes three numbers as arguments and returns the
    sum of the squares of the two larger numbers.
  </p>
  <textarea name="e1.3-01"></textarea>
  <output for="e1.3-01" class="block">&ZeroWidthSpace;</output>
</section>

<section id="e1.4">
  <h5><a href="#e1.4">Exercise 1.4</a></h5>
  <p>
    Observe that our model of evaluation allows for combinations whose
    operators are compound expressions. Use this observation to describe the
    behavior of the following procedure:
  </p>
  <textarea name="e1.4-01" rows="2">
(define (a-plus-abs-b a b)
  ((if (&gt; b 0) + -) a b))</textarea>
  <output for="e1.4-01" class="block">a-plus-abs-b</output>
</section>

<section id="e1.5">
  <h5><a href="#e1.5">Exercise 1.5</a></h5>
  <p>
    Ben Bitdiddle has invented a test to determine whether the interpreter he
    is faced with is using applicative-order evaluation or normal-order
    evaluation. He defines the following two procedures:
  </p>
  <textarea name="e1.5-01" rows="6">
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))</textarea>
  <output for="e1.5-01" class="block">p
test</output>
  <p>
    Then he evaluates the expression
  </p>
  <textarea name="e1.5-02" data-extends="e1.5-01">(test 0 (p))</textarea>
  <output for="e1.5-02" class="block">&ZeroWidthSpace;</output>
  <p>
    What behavior will Ben observe with an interpreter that uses
    applicative-order evaluation? What behavior will he observe with an
    interpreter that uses normal-order evaluation? Explain your answer. (Assume
    that the evaluation rule for the special form <code>if</code> is the same
    whether the interpreter is using normal or applicative order: The predicate
    expression is evaluated first, and the result determines whether to
    evaluate the consequent or the alternative expression.)
  </p>
</section>

<section id="s1.1.7">
  <h4><a href="#s1.1.7">1.1.7 Example: Square Roots by Newton’s Method</a></h4>
  <p>
    Procedures, as introduced above, are much like ordinary mathematical
    functions. They specify a value that is determined by one or more
    parameters. But there is an important difference between mathematical
    functions and computer procedures. Procedures must be effective.
  </p>
  <p>
    As a case in point, consider the problem of computing square roots. We can
    define the square-root function as
  </p>
  <figure>
    <math>
      <mrow>
        <msqrt><mi>x</mi></msqrt><mo>=</mo>
        <mtext>the </mtext><mi>y</mi><mtext> such that </mtext>
        <mi>y</mi><mo>&GreaterEqual;</mo><mn>0</mn>
        <mtext> and </mtext>
        <msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><mi>x</mi>
      </mrow>
    </math>
  </figure>
  <p>
    This describes a perfectly legitimate mathematical function. We could use
    it to recognize whether one number is the square root of another, or to
    derive facts about square roots in general. On the other hand, the
    definition does not describe a procedure. Indeed, it tells us almost
    nothing about how to actually find the square root of a given number. It
    will not help matters to rephrase this definition in pseudo-Lisp:
  </p>
  <pre><code>(define (sqrt x)
  (the y (and (&gt;= y 0)
              (= (square y) x))))</code></pre>
  <p>
    This only begs the question.
  </p>
  <p>
    The contrast between function and procedure is a reflection of the general
    distinction between describing properties of things and describing how to
    do things, or, as it is sometimes referred to, the distinction between
    declarative knowledge and imperative knowledge. In mathematics we are
    usually concerned with declarative (what is) descriptions, whereas in
    computer science we are usually concerned with imperative (how to)
    descriptions.<sup id="r1.20s"><a href="#r1.20d">20</a></sup>
  </p>
  <p>
    How does one compute square roots? The most common way is to use Newton’s
    method of successive approximations, which says that whenever we have a
    guess <code>y</code> for the value of the square root of a number
    <code>x</code>, we can perform a simple manipulation to get a better guess
    (one closer to the actual square root) by averaging <code>y</code> with
    <code>x/y</code>.<sup id="r1.21s"><a href="#r1.21d">21</a></sup> For
    example, we can compute the square root of 2 as follows. Suppose our
    initial guess is 1:
  </p>
  <table>
    <thead>
      <tr>
        <th>Guess</th>
        <th>Quotient</th>
        <th>Average</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td>(2/1) = 2</td>
        <td>((2 + 1)/2) = 1.5</td>
      </tr>
      <tr>
        <td>1.5</td>
        <td>(2/1.5) = 1.3333</td>
        <td>((1.3333 + 1.5)/2) = 1.4167</td>
      </tr>
      <tr>
        <td>1.4167</td>
        <td>(2/1.4167) = 1.4118</td>
        <td>((1.4167 + 1.4118)/2) = 1.4142</td>
      </tr>
      <tr>
        <td>1.4142</td>
        <td>...</td>
        <td>...</td>
      </tr>
    </tbody>
  </table>
  <p>
    Continuing this process, we obtain better and better approximations to the
    square root.
  </p>
  <p>
    Now let’s formalize the process in terms of procedures. We start with a
    value for the radicand (the number whose square root we are trying to
    compute) and a value for the guess. If the guess is good enough for our
    purposes, we are done; if not, we must repeat the process with an improved
    guess. We write this basic strategy as a procedure:
  </p>
  <textarea name="1.1.7-01" data-extends="1.1.4-01 1.1.6-03" rows="5">
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))</textarea>
  <output for="1.1.7-01" class="block">sqrt-iter</output>
  <p>
    A guess is improved by averaging it with the quotient of the radicand and
    the old guess:
  </p>
  <textarea name="1.1.7-02" data-extends="1.1.4-01 1.1.6-03 1.1.7-01" rows="2">
(define (improve guess x)
  (average guess (/ x guess)))</textarea>
  <output for="1.1.7-02" class="block">improve</output>
  <p>
    where
  </p>
  <textarea name="1.1.7-03" data-extends="1.1.4-01 1.1.6-03 1.1.7-01 1.1.7-02"
    rows="2">
(define (average x y)
  (/ (+ x y) 2))</textarea>
  <output for="1.1.7-03" class="block">average</output>
  <p>
    We also have to say what we mean by “good enough.” The following will do
    for illustration, but it is not really a very good test. (See exercise <a
    href="#e1.7">1.7</a>.) The idea is to improve the answer until it is close
    enough so that its square differs from the radicand by less than a
    predetermined tolerance (here 0.001):<sup id="r1.22s"><a href="#r1.22d"
    >22</a></sup>
  </p>
  <textarea name="1.1.7-04"
    data-extends="1.1.4-01 1.1.6-03 1.1.7-01 1.1.7-02 1.1.7-03" rows="2">
(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))</textarea>
  <output for="1.1.7-04" class="block">good-enough?</output>
  <p>
    Finally, we need a way to get started. For instance, we can always guess
    that the square root of any number is 1:<sup id="r1.23s"><a href="#r1.23d"
    >23</a></sup>
  </p>
  <textarea name="1.1.7-05"
    data-extends="1.1.4-01 1.1.6-03 1.1.7-01 1.1.7-02 1.1.7-03 1.1.7-04"
    rows="2">
(define (sqrt x)
  (sqrt-iter 1.0 x))</textarea>
  <output for="1.1.7-05" class="block">sqrt</output>
  <p>
    If we type these definitions to the interpreter, we can use sqrt just as we
    can use any procedure:
  </p>
  <textarea name="1.1.7-06"
    data-extends="1.1.4-01 1.1.6-03 1.1.7-01 1.1.7-02 1.1.7-03 1.1.7-04 1.1.7-05"
    rows="4">
(sqrt 9)
(sqrt (+ 100 37))
(sqrt (+ (sqrt 2) (sqrt 3)))
(square (sqrt 1000))</textarea>
  <output for="1.1.7-06" class="block">3.00009155413138
11.704699917758145
1.7739279023207892
1000.000369924366</output>
  <p>
    The <code>sqrt</code> program also illustrates that the simple procedural
    language we have introduced so far is sufficient for writing any purely
    numerical program that one could write in, say, C or Pascal. This might
    seem surprising, since we have not included in our language any iterative
    (looping) constructs that direct the computer to do something over and over
    again. <code>Sqrt-iter</code>, on the other hand, demonstrates how
    iteration can be accomplished using no special construct other than the
    ordinary ability to call a procedure.<sup id="r1.24s"><a href="#r1.24d"
    >24</a></sup>
  </p>
</section>

<section id="e1.6">
  <h5><a href="#e1.6">Exercise 1.6</a></h5>
  <p>
    Alyssa P. Hacker doesn’t see why <code>if</code> needs to be provided as a
    special form. “Why can’t I just define it as an ordinary procedure in terms
    of <code>cond</code>?” she asks. Alyssa’s friend Eva Lu Ator claims this
    can indeed be done, and she defines a new version of <code>if</code>:
  </p>
  <textarea name="e1.6-01" rows="3">
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))</textarea>
  <p>
    Eva demonstrates the program for Alyssa:
  </p>
  <textarea name="e1.6-02" data-extends="e1.6-01" rows="3">
(new-if (= 2 3) 0 5)

(new-if (= 1 1) 0 5)</textarea>
<output for="e1.6-02" class="block">5
0</output>
  <p>
    Delighted, Alyssa uses <code>new-if</code> to rewrite the
    <code>square-root</code> program:
  </p>
  <textarea name="e1.6-03"
    data-extends="1.1.4-01 1.1.6-03 1.1.7-02 1.1.7-03 1.1.7-04 e1.6-01"
    rows="5">
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))</textarea>
<output for="e1.6-03" class="block">sqrt-iter</output>
  <p>
    What happens when Alyssa attempts to use this to compute square roots?
    Explain.
  </p>
</section>

<section id="e1.7">
  <h5><a href="#e1.7">Exercise 1.7</a></h5>
  <p>
    The <code>good-enough?</code> test used in computing square roots will not
    be very effective for finding the square roots of very small numbers. Also,
    in real computers, arithmetic operations are almost always performed with
    limited precision. This makes our test inadequate for very large numbers.
    Explain these statements, with examples showing how the test fails for
    small and large numbers. An alternative strategy for implementing
    <code>good-enough?</code> is to watch how guess changes from one iteration
    to the next and to stop when the change is a very small fraction of the
    guess. Design a <code>square-root</code> procedure that uses this kind of
    end test. Does this work better for small and large numbers?
  </p>
  <textarea name="e1.7-01"
    data-extends="1.1.4-01 1.1.6-03 1.1.7-02 1.1.7-03 1.1.7-05" rows="5">
(define (sqrt-iter guess x)
  ???)
(define (good-enough? ???)
  ???)
(sqrt 9)</textarea>
  <output for="e1.7-01" class="block">&ZeroWidthSpace;</output>
</section>

<section id="e1.8">
  <h5><a href="#e1.8">Exercise 1.8</a></h5>
  <p>
    Newton’s method for cube roots is based on the fact that if <code>y</code>
    is an approximation to the cube root of <code>x</code>, then a better
    approximation is given by the value
  </p>
  <figure>
    <math>
      <mfrac>
        <mrow><mi>x</mi><mo>/</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo>
          <mn>2</mn><mi>y</mi></mrow>
        <mrow><mn>3</mn></mrow>
      </mfrac>
    </math>
  </figure>
  <p>
    Use this formula to implement a <code>cube-root</code> procedure analogous
    to the <code>square-root</code> procedure. (In section <a href="#s1.3.4"
    >1.3.4</a> we will see how to implement Newton’s method in general as an
    abstraction of these <code>square-root</code> and <code>cube-root</code>
    procedures.)
  </p>
  <textarea name="e1.8-01"></textarea>
  <output for="e1.8-01" class="block">&ZeroWidthSpace;</output>
</section>

<section id="s1.1.8">
  <h4><a href="#s1.1.8">1.1.8 Procedures as Black-Box Abstractions</a></h4>
  <p>
    <code>Sqrt</code> is our first example of a process defined by a set of
    mutually defined procedures. Notice that the definition of
    <code>sqrt-iter</code> is recursive; that is, the procedure is defined in
    terms of itself. The idea of being able to define a procedure in terms of
    itself may be disturbing; it may seem unclear how such a “circular”
    definition could make sense at all, much less specify a well-defined
    process to be carried out by a computer. This will be addressed more
    carefully in section <a href="#s1.2">1.2</a>. But first let’s consider some
    other important points illustrated by the <code>sqrt</code> example.
  </p>
  <p>
    Observe that the problem of computing square roots breaks up naturally into
    a number of subproblems: how to tell whether a guess is good enough, how to
    improve a guess, and so on. Each of these tasks is accomplished by a
    separate procedure. The entire <code>sqrt</code> program can be viewed as a
    cluster of procedures (shown in figure <a href="#f1.2">1.2</a>) that
    mirrors the decomposition of the problem into subproblems.
  </p>
  <figure>
    <img alt="Figure 1.2: Procedural decomposition of the sqrt program"
      src="./img/f1.2.gif">
    <figcaption>
      Figure 1.2: Procedural decomposition of the <code>sqrt</code> program.
    </figcaption>
  </figure>
  <p>
    The importance of this decomposition strategy is not simply that one is
    dividing the program into parts. After all, we could take any large program
    and divide it into parts—the first ten lines, the next ten lines, the next
    ten lines, and so on. Rather, it is crucial that each procedure
    accomplishes an identifiable task that can be used as a module in defining
    other procedures. For example, when we define the <code>good-enough?</code>
    procedure in terms of <code>square</code>, we are able to regard the
    <code>square</code> procedure as a “black box.” We are not at that moment
    concerned with how the procedure computes its result, only with the fact
    that it computes the square. The details of how the square is computed can
    be suppressed, to be considered at a later time. Indeed, as far as
    the <code>good-enough?</code> procedure is concerned, <code>square</code>
    is not quite a procedure but rather an abstraction of a procedure, a
    so-called procedural abstraction. At this level of abstraction, any
    procedure that computes the square is equally good.
  </p>
  <p>
    Thus, considering only the values they return, the following two procedures
    for squaring a number should be indistinguishable. Each takes a numerical
    argument and produces the square of that number as the value.<sup
    id="r1.25s"><a href="#r1.25d">25</a></sup>
  </p>
  <pre><code>(define (square x) (* x x))

(define (square x) 
  (exp (double (log x))))

(define (double x) (+ x x))</code></pre>
  <p>
    So a procedure definition should be able to suppress detail. The users of
    the procedure may not have written the procedure themselves, but may have
    obtained it from another programmer as a black box. A user should not need
    to know how the procedure is implemented in order to use it.
  </p>
  <h5>Local names</h5>
  <p>
    One detail of a procedure’s implementation that should not matter to the
    user of the procedure is the implementer’s choice of names for the
    procedure’s formal parameters. Thus, the following procedures should not be
    distinguishable:
  </p>
  <pre><code>(define (square x) (* x x))

(define (square y) (* y y))</code></pre>
  <p>
    This principle—that the meaning of a procedure should be independent of the
    parameter names used by its author—seems on the surface to be self-evident,
    but its consequences are profound. The simplest consequence is that the
    parameter names of a procedure must be local to the body of the procedure.
    For example, we used <code>square</code> in the definition of
    <code>good-enough?</code> in our <code>square-root</code> procedure:
  </p>
  <pre><code>(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))</code></pre>
  <p>
    The intention of the author of <code>good-enough?</code> is to determine if
    the square of the first argument is within a given tolerance of the second
    argument. We see that the author of <code>good-enough?</code> used the name
    <code>guess</code> to refer to the first argument and <code>x</code> to
    refer to the second argument. The argument of <code>square</code> is
    <code>guess</code>. If the author of <code>square</code> used
    <code>x</code> (as above) to refer to that argument, we see that the
    <code>x</code> in <code>good-enough?</code> must be a different
    <code>x</code> than the one in <code>square</code>. Running the procedure
    <code>square</code> must not affect the value of <code>x</code> that is
    used by <code>good-enough?</code>, because that value of <code>x</code> may
    be needed by <code>good-enough?</code> after <code>square</code> is done
    computing.
  </p>
  <p>
    If the parameters were not local to the bodies of their respective
    procedures, then the parameter <code>x</code> in <code>square</code> could
    be confused with the parameter <code>x</code> in <code>good-enough?</code>,
    and the behavior of <code>good-enough?</code> would depend upon which
    version of <code>square</code> we used. Thus, <code>square</code> would not
    be the black box we desired.
  </p>
  <p>
    A formal parameter of a procedure has a very special role in the procedure
    definition, in that it doesn’t matter what name the formal parameter has.
    Such a name is called a <em>bound variable</em>, and we say that the
    procedure definition <em>binds</em> its formal parameters. The meaning of a
    procedure definition is unchanged if a bound variable is consistently
    renamed throughout the definition.<sup id="r1.26s"><a href="#r1.26d"
    >26</a></sup> If a variable is not bound, we say that it is <em>free</em>.
    The set of expressions for which a binding defines a name is called the
    <em>scope</em> of that name. In a procedure definition, the bound variables
    declared as the formal parameters of the procedure have the body of the
    procedure as their scope.
  </p>
  <p>
    In the definition of <code>good-enough?</code> above, <code>guess</code>
    and <code>x</code> are bound variables but <code>&lt;</code>,
    <code>-</code>, <code>abs</code>, and <code>square</code> are free. The
    meaning of <code>good-enough?</code> should be independent of the names we
    choose for <code>guess</code> and <code>x</code> so long as they are
    distinct and different from <code>&lt;</code>, <code>-</code>,
    <code>abs</code>, and <code>square</code>. (If we renamed
    <code>guess</code> to <code>abs</code> we would have introduced a bug by
    <em>capturing</em> the variable <code>abs</code>. It would have changed
    from free to bound.) The meaning of <code>good-enough?</code> is not
    independent of the names of its free variables, however. It surely depends
    upon the fact (external to this definition) that the symbol
    <code>abs</code> names a procedure for computing the absolute value of a
    number. <code>Good-enough?</code> will compute a different function if we
    substitute <code>cos</code> for <code>abs</code> in its definition.
  </p>
  <h5>Internal definitions and block structure</h5>
  <p>
    We have one kind of name isolation available to us so far: The formal
    parameters of a procedure are local to the body of the procedure. The
    <code>square-root</code> program illustrates another way in which we would
    like to control the use of names. The existing program consists of separate
    procedures:
  </p>
  <textarea name="1.1.8-01" data-extends="1.1.4-01 1.1.6-03 1.1.7-03"
    rows="10">
(define (sqrt x)
  (sqrt-iter 1.0 x))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
(define (improve guess x)
  (average guess (/ x guess)))</textarea>
  <output for="1.1.8-01" class="block">sqrt
sqrt-iter
good-enough?
improve</output>
  <p>
    The problem with this program is that the only procedure that is important
    to users of <code>sqrt</code> is <code>sqrt</code>. The other procedures
    (<code>sqrt-iter</code>, <code>good-enough?</code>, and
    <code>improve</code>) only clutter up their minds. They may not define any
    other procedure called <code>good-enough?</code> as part of another program
    to work together with the <code>square-root</code> program, because
    <code>sqrt</code> needs it. The problem is especially severe in the
    construction of large systems by many separate programmers. For example, in
    the construction of a large library of numerical procedures, many numerical
    functions are computed as successive approximations and thus might have
    procedures named <code>good-enough?</code> and <code>improve</code> as
    auxiliary procedures. We would like to localize the subprocedures, hiding
    them inside <code>sqrt</code> so that <code>sqrt</code> could coexist with
    other successive approximations, each having its own private
    <code>good-enough?</code> procedure. To make this possible, we allow a
    procedure to have internal definitions that are local to that procedure.
    For example, in the <code>square-root</code> problem we can write
  </p>
  <textarea name="1.1.8-02" data-extends="1.1.4-01 1.1.6-02 1.1.7-03"
    rows="10">
(define (sqrt x)
  (define (good-enough? guess x)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))</textarea>
  <output for="1.1.8-02" class="block">sqrt</output>
  <p>
    Such nesting of definitions, called <em>block structure</em>, is basically
    the right solution to the simplest name-packaging problem. But there is a
    better idea lurking here. In addition to internalizing the definitions of
    the auxiliary procedures, we can simplify them. Since <code>x</code> is
    bound in the definition of <code>sqrt</code>, the procedures
    <code>good-enough?</code>, <code>improve</code>, and
    <code>sqrt-iter</code>, which are defined internally to <code>sqrt</code>,
    are in the scope of <code>x</code>. Thus, it is not necessary to pass
    <code>x</code> explicitly to each of these procedures. Instead, we allow
    <code>x</code> to be a free variable in the internal definitions, as shown
    below. Then <code>x</code> gets its value from the argument with which the
    enclosing procedure <code>sqrt</code> is called. This discipline is called
    <em>lexical scoping</em>.<sup id="r1.27s"><a href="#r1.27d">27</a></sup>
  </p>
  <textarea name="1.1.8-03" data-extends="1.1.4-01 1.1.6-02 1.1.7-03"
    rows="10">
(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))</textarea>
  <output for="1.1.8-03" class="block">sqrt</output>
  <p>
    We will use block structure extensively to help us break up large programs
    into tractable pieces.<sup id="r1.28s"><a href="#r1.28d">28</a></sup> The
    idea of block structure originated with the programming language Algol 60.
    It appears in most advanced programming languages and is an important tool
    for helping to organize the construction of large programs.
  </p>
  <hr>
</section>

<footer>
  <p>
    <sup id="r1.4d"><a href="#r1.4s">4</a></sup> The characterization of
    numbers as “simple data” is a barefaced bluff. In fact, the treatment of
    numbers is one of the trickiest and most confusing aspects of any
    programming language. Some typical issues involved are these: Some computer
    systems distinguish <em>integers</em>, such as 2, from <em>real
    numbers</em>, such as 2.71. Is the real number 2.00 different from the
    integer 2? Are the arithmetic operations used for integers the same as the
    operations used for real numbers? Does 6 divided by 2 produce 3, or 3.0?
    How large a number can we represent? How many decimal places of accuracy
    can we represent? Is the range of integers the same as the range of real
    numbers? Above and beyond these questions, of course, lies a collection of
    issues concerning roundoff and truncation errors—the entire science of
    numerical analysis. Since our focus in this book is on large-scale program
    design rather than on numerical techniques, we are going to ignore these
    problems. The numerical examples in this chapter will exhibit the usual
    roundoff behavior that one observes when using arithmetic operations that
    preserve a limited number of decimal places of accuracy in noninteger
    operations.
  </p>
  <p>
    <sup id="r1.5d"><a href="#r1.5s">5</a></sup> Throughout this book, when we
    wish to emphasize the distinction between the input typed by the user and
    the response printed by the interpreter, we will show the latter in slanted
    characters.
  </p>
  <p>
    <sup id="r1.6d"><a href="#r1.6s">6</a></sup> Lisp systems typically provide
    features to aid the user in formatting expressions. Two especially useful
    features are one that automatically indents to the proper pretty-print
    position whenever a new line is started and one that highlights the
    matching left parenthesis whenever a right parenthesis is typed.
  </p>
  <p>
    <sup id="r1.7d"><a href="#r1.7s">7</a></sup> Lisp obeys the convention that
    every expression has a value. This convention, together with the old
    reputation of Lisp as an inefficient language, is the source of the quip by
    Alan Perlis (paraphrasing Oscar Wilde) that “Lisp programmers know the
    value of everything but the cost of nothing.”
  </p>
  <p>
    <sup id="r1.8d"><a href="#r1.8s">8</a></sup> In this book, we do not show
    the interpreter’s response to evaluating definitions, since this is highly
    implementation-dependent.
  </p>
  <p>
    <sup id="r1.9d"><a href="#r1.9s">9</a></sup> Chapter 3 will show that this
    notion of environment is crucial, both for understanding how the
    interpreter works and for implementing interpreters.
  </p>
  <p>
    <sup id="r1.10d"><a href="#r1.10s">10</a></sup> It may seem strange that
    the evaluation rule says, as part of the first step, that we should
    evaluate the leftmost element of a combination, since at this point that
    can only be an operator such as <code>+</code> or <code>*</code>
    representing a built-in primitive procedure such as addition or
    multiplication. We will see later that it is useful to be able to work with
    combinations whose operators are themselves compound expressions.
  </p>
  <p>
    <sup id="r1.11d"><a href="#r1.11s">11</a></sup> Special syntactic forms
    that are simply convenient alternative surface structures for things that
    can be written in more uniform ways are sometimes called <em>syntactic
    sugar</em>, to use a phrase coined by Peter Landin. In comparison with
    users of other languages, Lisp programmers, as a rule, are less concerned
    with matters of syntax. (By contrast, examine any Pascal manual and notice
    how much of it is devoted to descriptions of syntax.) This disdain for
    syntax is due partly to the flexibility of Lisp, which makes it easy to
    change surface syntax, and partly to the observation that many “convenient”
    syntactic constructs, which make the language less uniform, end up causing
    more trouble than they are worth when programs become large and complex. In
    the words of Alan Perlis, “Syntactic sugar causes cancer of the semicolon.”
  </p>
  <p>
    <sup id="r1.12d"><a href="#r1.12s">12</a></sup> Observe that there are two
    different operations being combined here: we are creating the procedure,
    and we are giving it the name <code>square</code>. It is possible, indeed
    important, to be able to separate these two notions—to create procedures
    without naming them, and to give names to procedures that have already been
    created. We will see how to do this in section <a href="#s1.3.2">1.3.2</a>.
  </p>
  <p>
    <sup id="r1.13d"><a href="#r1.13s">13</a></sup> Throughout this book, we
    will describe the general syntax of expressions by using italic symbols
    delimited by angle brackets—e.g., <code><em>&lt;name&gt;</em></code>—to
    denote the “slots” in the expression to be filled in when such an
    expression is actually used.
  </p>
  <p>
    <sup id="r1.14d"><a href="#r1.14s">14</a></sup> More generally, the body of
    the procedure can be a sequence of expressions. In this case, the
    interpreter evaluates each expression in the sequence in turn and returns
    the value of the final expression as the value of the procedure
    application.
  </p>
  <p>
    <sup id="r1.15d"><a href="#r1.15s">15</a></sup> Despite the simplicity of
    the substitution idea, it turns out to be surprisingly complicated to give
    a rigorous mathematical definition of the substitution process. The problem
    arises from the possibility of confusion between the names used for the
    formal parameters of a procedure and the (possibly identical) names used in
    the expressions to which the procedure may be applied. Indeed, there is a
    long history of erroneous definitions of substitution in the literature of
    logic and programming semantics. See Stoy 1977 for a careful discussion of
    substitution.
  </p>
  <p>
    <sup id="r1.16d"><a href="#r1.16s">16</a></sup> In chapter 3 we will
    introduce <em>stream processing</em>, which is a way of handling apparently
    “infinite” data structures by incorporating a limited form of normal-order
    evaluation. In section <a href="#s4.2">4.2</a> we will modify the Scheme
    interpreter to produce a normal-order variant of Scheme.
  </p>
  <p>
    <sup id="r1.17d"><a href="#r1.17s">17</a></sup> “Interpreted as either true
    or false” means this: In Scheme, there are two distinguished values that
    are denoted by the constants <code>#t</code> and <code>#f</code>. When the
    interpreter checks a predicate’s value, it interprets <code>#f</code> as
    false. Any other value is treated as true. (Thus, providing <code>#t</code>
    is logically unnecessary, but it is convenient.) In this book we will use
    names true and false, which are associated with the values <code>#t</code>
    and <code>#f</code> respectively.
  </p>
  <p>
    <sup id="r1.18d"><a href="#r1.18s">18</a></sup> Abs also uses the “minus”
    operator <code>-</code>, which, when used with a single operand, as in
    <code>(-&nbsp;x)</code>, indicates negation.
  </p>
  <p>
    <sup id="r1.19d"><a href="#r1.19s">19</a></sup> A minor difference between
    <code>if</code> and <code>cond</code> is that the <code><em>&lt;e&gt;</em
    ></code> part of each cond clause may be a sequence of expressions. If the
    corresponding <code><em>&lt;p&gt;</em></code> is found to be true, the
    expressions <code><em>&lt;e&gt;</em></code> are evaluated in sequence and
    the value of the final expression in the sequence is returned as the value
    of the <code>cond</code>. In an <code>if</code> expression, however, the
    <code><em>&lt;consequent&gt;</em></code> and <code><em
    >&lt;alternative&gt;</em></code> must be single expressions.
  </p>
  <p>
    <sup id="r1.20d"><a href="#r1.20s">20</a></sup> Declarative and imperative
    descriptions are intimately related, as indeed are mathematics and computer
    science. For instance, to say that the answer produced by a program is
    “correct” is to make a declarative statement about the program. There is a
    large amount of research aimed at establishing techniques for proving that
    programs are correct, and much of the technical difficulty of this subject
    has to do with negotiating the transition between imperative statements
    (from which programs are constructed) and declarative statements (which can
    be used to deduce things). In a related vein, an important current area in
    programming-language design is the exploration of so-called very high-level
    languages, in which one actually programs in terms of declarative
    statements. The idea is to make interpreters sophisticated enough so that,
    given “what is” knowledge specified by the programmer, they can generate
    “how to” knowledge automatically. This cannot be done in general, but there
    are important areas where progress has been made. We shall revisit this
    idea in chapter 4.
  </p>
  <p>
    <sup id="r1.21d"><a href="#r1.21s">21</a></sup> This square-root algorithm
    is actually a special case of Newton’s method, which is a general technique
    for finding roots of equations. The square-root algorithm itself was
    developed by Heron of Alexandria in the first century A.D. We will see how
    to express the general Newton’s method as a Lisp procedure in section <a
    href="#s1.3.4">1.3.4</a>.
  </p>
  <p>
    <sup id="r1.22d"><a href="#r1.22s">22</a></sup> We will usually give
    predicates names ending with question marks, to help us remember that they
    are predicates. This is just a stylistic convention. As far as the
    interpreter is concerned, the question mark is just an ordinary character.
  </p>
  <p>
    <sup id="r1.23d"><a href="#r1.23s">23</a></sup> Observe that we express our
    initial guess as 1.0 rather than 1. This would not make any difference in
    many Lisp implementations. MIT Scheme, however, distinguishes between exact
    integers and decimal values, and dividing two integers produces a rational
    number rather than a decimal. For example, dividing 10 by 6 yields 5/3,
    while dividing 10.0 by 6.0 yields 1.6666666666666667. (We will learn how to
    implement arithmetic on rational numbers in section <a href="#s2.1.1"
    >2.1.1</a>.) If we start with an initial guess of 1 in our square-root
    program, and x is an exact integer, all subsequent values produced in the
    square-root computation will be rational numbers rather than decimals.
    Mixed operations on rational numbers and decimals always yield decimals, so
    starting with an initial guess of 1.0 forces all subsequent values to be
    decimals.
  </p>
  <p>
    <sup id="r1.24d"><a href="#r1.24s">24</a></sup> Readers who are worried
    about the efficiency issues involved in using procedure calls to implement
    iteration should note the remarks on “tail recursion” in section <a
    href="#s1.2.1">1.2.1</a>.
  </p>
  <p>
    <sup id="r1.25d"><a href="#r1.25s">25</a></sup> It is not even clear which
    of these procedures is a more efficient implementation. This depends upon
    the hardware available. There are machines for which the “obvious”
    implementation is the less efficient one. Consider a machine that has
    extensive tables of logarithms and antilogarithms stored in a very
    efficient manner.
  </p>
  <p>
    <sup id="r1.26d"><a href="#r1.26s">26</a></sup> The concept of consistent
    renaming is actually subtle and difficult to define formally. Famous
    logicians have made embarrassing errors here.
  </p>
  <p>
    <sup id="r1.27d"><a href="#r1.27s">27</a></sup> Lexical scoping dictates
    that free variables in a procedure are taken to refer to bindings made by
    enclosing procedure definitions; that is, they are looked up in the
    environment in which the procedure was defined. We will see how this works
    in detail in chapter 3 when we study environments and the detailed behavior
    of the interpreter.
  </p>
  <p>
    <sup id="r1.28d"><a href="#r1.28s">28</a></sup> Embedded definitions must
    come first in a procedure body. The management is not responsible for the
    consequences of running programs that intertwine definition and use.
  </p>
</footer>
</section>
</section>

<section id="s1.2">
<section id="s1.2.0">
  <h3><a href="s#1.2">1.2 Procedures and the Processes They Generate</a></h3>
  <p>
    We have now considered the elements of programming: We have used primitive
    arithmetic operations, we have combined these operations, and we have
    abstracted these composite operations by defining them as compound
    procedures. But that is not enough to enable us to say that we know how to program. Our situation is analogous to that of someone who has learned the rules for how the pieces move in chess but knows nothing of typical openings, tactics, or strategy. Like the novice chess player, we don’t yet know the common patterns of usage in the domain. We lack the knowledge of which moves are worth making (which procedures are worth defining). We lack the experience to predict the consequences of making a move (executing a procedure).
  </p>
  <p>
    The ability to visualize the consequences of the actions under
    consideration is crucial to becoming an expert programmer, just as it is in
    any synthetic, creative activity. In becoming an expert photographer, for
    example, one must learn how to look at a scene and know how dark each
    region will appear on a print for each possible choice of exposure and
    development conditions. Only then can one reason backward, planning
    framing, lighting, exposure, and development to obtain the desired effects.
    So it is with programming, where we are planning the course of action to be
    taken by a process and where we control the process by means of a program.
    To become experts, we must learn to visualize the processes generated by
    various types of procedures. Only after we have developed such a skill can
    we learn to reliably construct programs that exhibit the desired behavior.
  </p>
  <p>
    A procedure is a pattern for the <em>local evolution</em> of a
    computational process. It specifies how each stage of the process is built
    upon the previous stage. We would like to be able to make statements about
    the overall, or <em>global</em>, behavior of a process whose local
    evolution has been specified by a procedure. This is very difficult to do
    in general, but we can at least try to describe some typical patterns of
    process evolution.
  </p>
  <p>
    In this section we will examine some common “shapes” for processes
    generated by simple procedures. We will also investigate the rates at which
    these processes consume the important computational resources of time and
    space. The procedures we will consider are very simple. Their role is like
    that played by test patterns in photography: as oversimplified prototypical
    patterns, rather than practical examples in their own right.
  </p>
</section>

<section id="s1.2.1">
  <h4><a href="#s1.2.1">1.2.1 Linear Recursion and Iteration</a></h4>
  <figure id="f1.3">
    <img alt="Figure 1.3: A linear recursive process" src="./img/f1.3.gif">
    <figcaption>
      Figure 1.3: A linear recursive process for computing 6!
    </figcaption>
  </figure>
  <p>
    We begin by considering the factorial function, defined by
  </p>
  <figure>
    <math>
      <mrow>
        <mi>n</mi><mo>!</mo><mo>=</mo>
        <mi>n</mi><mo>⋅</mo>
        <mo>&lpar;</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>&rpar;</mo><mo>⋅</mo>
        <mo>&lpar;</mo><mi>n</mi><mo>-</mo><mn>2</mn><mo>&rpar;</mo>
        <mo>⋅⋅⋅</mo><mn>3</mn><mo>⋅</mo><mn>2</mn><mo>⋅</mo><mn>1</mn>
      </mrow>
    </math>
  </figure>
  <p>
    There are many ways to compute factorials. One way is to make use of the
    observation that <math><mi>n</mi><mo>!</mo></math> is equal to
    <math>n</math> times <math><mo>&lpar;</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo
    >&rpar;</mo><mo>!</mo></math> for any positive integer
    <math><mi>n</mi></math>:
  </p>
  <figure>
    <math>
      <mrow>
        <mi>n</mi><mo>!</mo><mo>=</mo>
        <mi>n</mi><mo>⋅</mo><mo>&lbrack;</mo>
        <mo>&lpar;</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>&rpar;</mo><mo>⋅</mo>
        <mo>&lpar;</mo><mi>n</mi><mo>-</mo><mn>2</mn><mo>&rpar;</mo>
        <mo>⋅⋅⋅</mo><mn>3</mn><mo>⋅</mo><mn>2</mn><mo>⋅</mo><mn>1</mn>
        <mo>&rbrack;</mo><mo>=</mo>
        <mi>n</mi><mo>⋅</mo>
        <mo>&lpar;</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>&rpar;</mo><mo>!</mo>
      </mrow>
    </math>
  </figure>
  <p>
    Thus, we can compute <math><mi>n</mi><mo>!</mo></math> by computing
    <math><mo>&lpar;</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>&rpar;</mo><mo
    >!</mo></math> and multiplying the result by <math><mi>n</mi></math>. If we
    add the stipulation that <math><mn>1</mn><mo>!</mo></math> is equal to
    <math><mn>1</mn></math>, this observation translates directly into a
    procedure:
  </p>
  <textarea name="1.2.1-01" rows="4">
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))</textarea>
  <output for="1.2.1-01" class="block">factorial</output>
  </p>
  <p>
    We can use the substitution model of section <a href="#s1.1.5">1.1.5</a> to
    watch this procedure in action computing <math><mn>6</mn><mo>!</mo></math>,
    as shown in figure <a href="#f1.3">1.3</a>.
  </p>
  <p>
    Now let’s take a different perspective on computing factorials. We could
    describe a rule for computing <math><mi>n</mi><mo>!</mo></math> by
    specifying that we first multiply <math><mn>1</mn></math> by
    <math><mn>2</mn></math>, then multiply the result by
    <math><mn>3</mn></math>, then by <math><mn>4</mn></math>, and so on until
    we reach <math><mi>n</mi></math>. More formally, we maintain a running
    product, together with a counter that counts from <math><mn>1</mn></math>
    up to <math><mi>n</mi></math>. We can describe the computation by saying
    that the counter and the product simultaneously change from one step to the
    next according to the rule
  </p>
  <figure>
    <math>
      <mtable>
        <mtr>
          <mtd><mtext>product</mtext><mo>&larr;</mo><mtext>counter</mtext><mo>⋅</mo><mtext>product</mtext></mtd>
        </mtr>
        <mtr>
          <mtd><mtext>counter</mtext><mo>&larr;</mo><mtext>counter</mtext><mo>+</mo><mn>1</mn></mtd>
        </mtr>
      </mtable>
    </math>
  </figure>
  <p>
    and stipulating that <math><mi>n</mi><mo>!</mo></math> is the value of the
    product when the counter exceeds <math><mi>n</mi></math>.
  </p>
  <figure id="f1.4">
    <img alt="Figure 1.4: A linear iterative process" src="./img/f1.4.gif">
    <figcaption>
      Figure 1.4: A linear iterative process for computing <math><mn>6</mn><mo
      >!</mo></math>.
    </figcaption>
  </figure>
  <p>
    Once again, we can recast our description as a procedure for computing
    factorials:<sup id="r1.29s"><a href="#r1.29d">29</a></sup>
  </p>
  <textarea name="1.2.1-02" rows="9">
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))</textarea>
  <output for="1.2.1-02" class="block">factorial
fact-iter</output>
  <p>
    As before, we can use the substitution model to visualize the process of
    computing <math><mn>6</mn><mo>!</mo></math>, as shown in figure
    <a href="#f1.4">1.4</a>.
  </p>
  <p>
    Compare the two processes. From one point of view, they seem hardly
    different at all. Both compute the same mathematical function on the same
    domain, and each requires a number of steps proportional to
    <math><mi>n</mi></math> to compute <math><mi>n</mi><mo>!</mo></math>.
    Indeed, both processes even carry out the same sequence of multiplications,
    obtaining the same sequence of partial products. On the other hand, when we
    consider the “shapes” of the two processes, we find that they evolve quite
    differently.
  </p>
  <p>
    Consider the first process. The substitution model reveals a shape of
    expansion followed by contraction, indicated by the arrow in figure <a
    href="#f1.3">1.3</a>. The expansion occurs as the process builds up a chain
    of <em>deferred operations</em> (in this case, a chain of multiplications).
    The contraction occurs as the operations are actually performed. This type
    of process, characterized by a chain of deferred operations, is called a
    <em>recursive process</em>. Carrying out this process requires that the
    interpreter keep track of the operations to be performed later on. In the
    computation of <math><mi>n</mi><mo>!</mo></math>, the length of the chain
    of deferred multiplications, and hence the amount of information needed to
    keep track of it, grows linearly with <math><mi>n</mi></math> (is
    proportional to <math><mi>n</mi></math>), just like the number of steps.
    Such a process is called a <em>linear recursive process</em>.
  </p>
  <p>
    By contrast, the second process does not grow and shrink. At each step, all
    we need to keep track of, for any <math><mi>n</mi></math>, are the current
    values of the variables <code>product</code>, <code>counter</code>, and
    <code>max-count</code>. We call this an <em>iterative process</em>. In
    general, an iterative process is one whose state can be summarized by a
    fixed number of <em>state variables</em>, together with a fixed rule that
    describes how the state variables should be updated as the process moves
    from state to state and an (optional) end test that specifies conditions
    under which the process should terminate. In computing
    <math><mi>n</mi><mo>!</mo></math>, the number of steps required grows
    linearly with <math><mi>n</mi></math>. Such a process is called a
    <em>linear iterative process</em>.
  </p>
  <p>
    The contrast between the two processes can be seen in another way. In the
    iterative case, the program variables provide a complete description of the
    state of the process at any point. If we stopped the computation between
    steps, all we would need to do to resume the computation is to supply the
    interpreter with the values of the three program variables. Not so with the
    recursive process. In this case there is some additional “hidden”
    information, maintained by the interpreter and not contained in the program
    variables, which indicates “where the process is” in negotiating the chain
    of deferred operations. The longer the chain, the more information must be
    maintained.<sup id="r1.30s"><a href="#r1.30d">30</a></sup>
  </p>
  <p>
    In contrasting iteration and recursion, we must be careful not to confuse
    the notion of a recursive <em>process</em> with the notion of a recursive
    <em>procedure</em>. When we describe a procedure as recursive, we are
    referring to the syntactic fact that the procedure definition refers
    (either directly or indirectly) to the procedure itself. But when we
    describe a process as following a pattern that is, say, linearly recursive,
    we are speaking about how the process evolves, not about the syntax of how
    a procedure is written. It may seem disturbing that we refer to a recursive
    procedure such as <code>fact-iter</code> as generating an iterative
    process. However, the process really is iterative: Its state is captured
    completely by its three state variables, and an interpreter need keep track
    of only three variables in order to execute the process.
  </p>
  <p>
    One reason that the distinction between process and procedure may be
    confusing is that most implementations of common languages (including Ada,
    Pascal, and C) are designed in such a way that the interpretation of any
    recursive procedure consumes an amount of memory that grows with the number
    of procedure calls, even when the process described is, in principle,
    iterative. As a consequence, these languages can describe iterative
    processes only by resorting to special-purpose “looping constructs” such as
    do, repeat, until, for, and while. The implementation of Scheme we shall
    consider in chapter 5 does not share this defect. It will execute an
    iterative process in constant space, even if the iterative process is
    described by a recursive procedure. An implementation with this property is
    called tail-recursive. With a tail-recursive implementation, iteration can
    be expressed using the ordinary procedure call mechanism, so that special
    iteration constructs are useful only as syntactic sugar.<sup id="r1.31s"><a
    href="#r1.31d">31</a></sup>
  </p>
</section>

<section id="e1.9">
  <h5><a href="#e1.9">Exercise 1.9</a></h5>
  <p>
    Each of the following two procedures defines a method for adding two
    positive integers in terms of the procedures <code>inc</code>, which
    increments its argument by <code>1</code>, and <code>dec</code>, which
    decrements its argument by <code>1</code>.
  </p>
  <textarea name="e1.9-01" rows="4">
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))</textarea>
  <output for="e1.9-01" class="block">+</output>
  <textarea name="e1.9-02" rows="4">
(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))</textarea>
  <output for="e1.9-02" class="block">+</output>
  <p>
    Using the substitution model, illustrate the process generated by each
    procedure in evaluating <code>(+ 4 5)</code>. Are these processes iterative
    or recursive?
  </p>
</section>
<section id="e1.10">
  <h5><a href="#e1.10">Exercise 1.10</a></h5>
  <p>
    The following procedure computes a mathematical function called Ackermann's
    function.
  </p>
  <textarea name="e1.10-01" rows="6">
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))</textarea>
  <output for="e1.10-01" class="block">A</output>
  <p>
    What are the values of the following expressions?
  </p>
  <textarea name="e1.10-02" data-extends="e1.10-01" rows="3">
(A 1 10)
(A 2 4)
(A 3 3)</textarea>
  <output for="e1.10-02" class="block">&ZeroWidthSpace;</output>
  <p>
    Consider the following procedures, where A is the procedure defined above:
  </p>
  <textarea name="e1.10-03" data-extends="e1.10-01" rows="4">
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))</textarea>
  <output for="e1.10-03" class="block">f
g
h
k</output>
  <p>
    Give concise mathematical definitions for the functions computed by the
    procedures <code>f</code>, <code>g</code>, and <code>h</code> for positive
    integer values of <math><mi>n</mi></math>. For example, <code>(k n)</code>
    computes <math><mn>5</mn><msup><mi>n</mi><mn>2</mn></msup></math>.
  </p>
</section>

<section id="s1.2.2">
  <h4><a href="#s1.2.2">1.2.2 Tree Recursion</a></h4>
  <p>
    Another common pattern of computation is called <em>tree recursion</em>. As
    an example, consider computing the sequence of Fibonacci numbers, in which
    each number is the sum of the preceding two:
  </p>
  <figure>
    <math>
      <mrow>
        <mn>0</mn><mtext>, </mtext><mn>1</mn><mtext>, </mtext><mn>1</mn>
        <mtext>, </mtext><mn>2</mn><mtext>, </mtext><mn>3</mn>
        <mtext>, </mtext><mn>5</mn><mtext>, </mtext><mn>8</mn>
        <mtext>, </mtext><mn>13</mn><mtext>, </mtext><mn>21</mn>
        <mtext>, </mtext><mn>…</mn>
      </mrow>
    </math>
  </figure>
  <p>
    In general, the Fibonacci numbers can be defined by the rule
  </p>
  <figure>
    <math>
      <mrow>
        <mrow>
          <mtext>Fib</mtext>
          <mo>&lpar;</mo>
          <mi>n</mi>
          <mo>&rpar;</mo>
        </mrow>
        <mo>=</mo>
        <mo>&lbrace;</mo>
        <mtable>
          <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mtext>if&nbsp;</mtext><mi>n</mi><mo>=</mo><mn>0</mn></mtd>
          </mtr>
          <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mtext>if&nbsp;</mtext><mi>n</mi><mo>=</mo><mn>1</mn></mtd>
          </mtr>
          <mtr>
            <mtd>
              <mtext>Fib</mtext><mo>&lpar;</mo><mi>n</mi><mo>-</mo><mn>1</mn>
              <mo>&rpar;</mo><mo>+</mo><mtext>Fib</mtext><mo>&lpar;</mo>
              <mi>n</mi><mo>-</mo><mn>2</mn><mo>&rpar;</mo>
            </mtd>
            <mtd><mtext>otherwise</mtext></mtd>
          </mtr>
        </mtable>
      </mrow>
    </math>
  </figure>
  <p>
    We can immediately translate this definition into a recursive procedure for
    computing Fibonacci numbers:
  </p>
  <textarea name="1.2.2-01">
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))</textarea>
  <output for="1.2.2-01" class="block">fib</output>
  <figure id="f1.5">
    <img alt="Figure 1.5: A tree-recursive process" src="./img/f1.5.gif">
    <figcaption>
      Figure 1.5: The tree-recursive process generated in computing
      <code>(fib&nbsp;5)</code>.
    </figcaption>
  </figure>
  <p>
    Consider the pattern of this computation. To compute <code>(fib 5)</code>,
    we compute <code>(fib 4)</code> and <code>(fib 3)</code>. To compute
    <code>(fib 4)</code>, we compute <code>(fib 3)</code> and <code>(fib
    2)</code>. In general, the evolved process looks like a tree, as shown in
    figure <a href="#f1.5">1.5</a>. Notice that the branches split into two at
    each level (except at the bottom); this reflects the fact that the
    <code>fib</code> procedure calls itself twice each time it is invoked.
  </p>
  <p>
    This procedure is instructive as a prototypical tree recursion, but it is a
    terrible way to compute Fibonacci numbers because it does so much redundant
    computation. Notice in figure <a href="#f1.5">1.5</a> that the entire
    computation of <code>(fib 3)</code>—almost half the work—is duplicated. In
    fact, it is not hard to show that the number of times the procedure will
    compute <code>(fib 1)</code> or <code>(fib 0)</code> (the number of leaves
    in the above tree, in general) is precisely <math><mtext>Fib</mtext><mo
    >&lpar;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>&rpar;</mo></math>. To get an
    idea of how bad this is, one can show that the value of <math><mtext
    >Fib</mtext><mo>&lpar;</mo><mi>n</mi><mo>&rpar;</mo></math> grows
    exponentially with <math><mi>n</mi></math>. More precisely (see exercise
    <a href="#e1.13">1.13</a>), <math><mtext>Fib</mtext><mo>&lpar;</mo><mi
    >n</mi><mo>&rpar;</mo></math> is the closest integer to <math><msup><mi
    >ϕ</mi><mn>5</mn></msup><mo>/</mo><msqrt><mn>5</mn></msqrt></math>, where
  </p>
  <figure>
    <math>
      <mrow>
        <mi>ϕ</mi><mo>=</mo>
        <mfrac>
          <mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow>
          <mn>2</mn>
        </mfrac>
        <mo>≈</mo><mn>1.6180</mn>
      </mrow>
    </math>
  </figure>
  <p>
    is the <em>golden ratio</em>, which satisfies the equation
  </p>
  <figure>
    <math>
      <mrow>
        <msup><mi>ϕ</mi><mn>2</mn></msup><mo>=</mo>
        <mi>ϕ</mi><mo>+</mo><mn>1</mn>
      </mrow>
    </math>
  </figure>
  <p>
    Thus, the process uses a number of steps that grows exponentially with the
    input. On the other hand, the space required grows only linearly with the
    input, because we need keep track only of which nodes are above us in the
    tree at any point in the computation. In general, the number of steps
    required by a tree-recursive process will be proportional to the number of
    nodes in the tree, while the space required will be proportional to the
    maximum depth of the tree.
  </p>
  <p>
    We can also formulate an iterative process for computing the Fibonacci
    numbers. The idea is to use a pair of integers <math><mi>a</mi></math> and
    <math><mi>b</mi></math>, initialized to <math><mtext>Fib</mtext><mo
    >&lpar;</mo><mn>1</mn><mo>&rpar;</mo><mo>=</mo><mn>1</mn></math> and
    <math><mtext>Fib</mtext><mo>&lpar;</mo><mn>0</mn><mo>&rpar;</mo><mo
    >=</mo><mn>0</mn></math>, and to repeatedly apply the simultaneous
    transformations
  </p>
  <figure>
    <math>
      <mtable>
        <mtr>
          <mtd><mi>a</mi><mo>&larr;</mo><mi>a</mi><mo>+</mo><mi>b</mi></mtd>
        </mtr>
        <mtr>
          <mtd><mi>b</mi><mo>&larr;</mo><mi>a</mi></mtd>
        </mtr>
      </mtable>
    </math>
  </figure>
  <p>
    It is not hard to show that, after applying this transformation <math><mi
    >n</mi></math> times, <math><mi>a</mi></math> and <math><mi>b</mi></math>
    will be equal, respectively, to <math><mtext>Fib</mtext><mo>&lpar;</mo><mi
    >n</mi><mo>+</mo><mn>1</mn><mo>&rpar;</mo></math> and <math><mtext
    >Fib</mtext><mo>&lpar;</mo><mi>n</mi><mo>&rpar;</mo></math>. Thus, we can
    compute Fibonacci numbers iteratively using the procedure
  </p>
  <textarea name="1.2.2-02">
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))</textarea>
  <output for="1.2.2-02" class="block">fib
fib-iter</output>
  <p>
    This second method for computing <math><mtext>Fib</mtext><mo>&lpar;</mo><mi
    >n</mi><mo>&rpar;</mo></math> is a linear iteration. The difference in
    number of steps required by the two methods—one linear in
    <math><mi>n</mi></math>, one growing as fast as <math><mtext
    >Fib</mtext><mo>&lpar;</mo><mi>n</mi><mo>&rpar;</mo></math> itself—is
    enormous, even for small inputs.
  </p>
  <p>
    One should not conclude from this that tree-recursive processes are
    useless. When we consider processes that operate on hierarchically
    structured data rather than numbers, we will find that tree recursion is a
    natural and powerful tool.<sup id="r1.32s"><a href="#r1.32d">32</a></sup>
    But even in numerical operations, tree-recursive processes can be useful in
    helping us to understand and design programs. For instance, although the
    first <code>fib</code> procedure is much less efficient than the second
    one, it is more straightforward, being little more than a translation into
    Lisp of the definition of the Fibonacci sequence. To formulate the
    iterative algorithm required noticing that the computation could be recast
    as an iteration with three state variables.
  </p>
</section>

<section id="ex1.1">
  <h5><a href="#ex1.1">Example: Counting change</a></h5>
  <p>
    It takes only a bit of cleverness to come up with the iterative Fibonacci
    algorithm. In contrast, consider the following problem: How many different
    ways can we make change of $1.00, given half-dollars, quarters, dimes,
    nickels, and pennies? More generally, can we write a procedure to compute
    the number of ways to change any given amount of money?
  </p>
  <p>
    This problem has a simple solution as a recursive procedure. Suppose we
    think of the types of coins available as arranged in some order. Then the
    following relation holds:
  </p>
  <p>
    The number of ways to change amount <math><mi>a</mi></math> using
    <math><mi>n</mi></math> kinds of coins equals
  </p>
  <ul>
    <li>
      the number of ways to change amount a using all but the first kind of
      coin, plus
    </li>
    <li>
      the number of ways to change amount <math><mi>a</mi><mo>-</mo><mi
      >d</mi></math> using all <math><mi>n</mi></math> kinds of coins, where
      <math><mi>d</mi></math> is the denomination of the first kind of coin.
    </li>
  </ul>
  <p>
    To see why this is true, observe that the ways to make change can be
    divided into two groups: those that do not use any of the first kind of
    coin, and those that do. Therefore, the total number of ways to make change
    for some amount is equal to the number of ways to make change for the
    amount without using any of the first kind of coin, plus the number of ways
    to make change assuming that we do use the first kind of coin. But the
    latter number is equal to the number of ways to make change for the amount
    that remains after using a coin of the first kind.
  </p>
  <p>
    Thus, we can recursively reduce the problem of changing a given amount to
    the problem of changing smaller amounts using fewer kinds of coins.
    Consider this reduction rule carefully, and convince yourself that we can
    use it to describe an algorithm if we specify the following degenerate
    cases:<sup id="r1.33s"><a href="#r1.33d">33</a></sup>
  </p>
  <ul>
    <li>
      If <math><mi>a</mi></math> is exactly <math><mn>0</mn></math>, we should
      count that as <math><mn>1</mn></math> way to make change.
    </li>
    <li>
      If <math><mi>a</mi></math> is less than <math><mn>0</mn></math>, we
      should count that as <math><mn>0</mn></math> ways to make change.
    </li>
    <li>
      If <math><mi>n</mi></math> is <math><mn>0</mn></math>, we should count
      that as <math><mn>0</mn></math> ways to make change.
    </li>
  </ul>
  <p>
    We can easily translate this description into a recursive procedure:
  </p>
  <textarea name="ex1.1-01">
(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))</textarea>
  <output for="ex1.1-01" class="block">count-change
cc
first-denomination</output>
  <p>
    (The <code>first-denomination</code> procedure takes as input the number of
    kinds of coins available and returns the denomination of the first kind.
    Here we are thinking of the coins as arranged in order from largest to
    smallest, but any order would do as well.) We can now answer our original
    question about changing a dollar:
  </p>
  <textarea name="ex1.1-02" data-extends="ex1.1-01">
(count-change 100)</textarea>
  <output for="ex1.1-02" class="block">292</output>
  <p>
    <code>Count-change</code> generates a tree-recursive process with
    redundancies similar to those in our first implementation of
    <code>fib</code>. (It will take quite a while for that 292 to be computed.)
    On the other hand, it is not obvious how to design a better algorithm for
    computing the result, and we leave this problem as a challenge. The
    observation that a tree-recursive process may be highly inefficient but
    often easy to specify and understand has led people to propose that one
    could get the best of both worlds by designing a “smart compiler” that
    could transform tree-recursive procedures into more efficient procedures
    that compute the same result.<sup id="r1.34s"><a href="#r1.34d"
    >34</a></sup>
  </p>
</section>

<section id="e1.11">
  <h5><a href="#e1.11">Exercise 1.11</a></h5>
  <p>
    A function <math><mi>f</mi></math> is defined by the rule that <math><mi
    >f</mi><mo>&lpar;</mo><mi>n</mi><mo>&rpar;</mo><mo>=</mo><mi>n</mi></math>
    if <math><mi>n</mi><mo>&lt;</mo><mn>3</mn></math> and <math><mi>f</mi><mo
    >&lpar;</mo><mi>n</mi><mo>&rpar;</mo><mo>=</mo><mi>f</mi><mo>&lpar;</mo><mi
    >n</mi><mo>-</mo><mn>1</mn><mo>&rpar;</mo><mo>+</mo><mn>2</mn><mi>f</mi><mo
    >&lpar;</mo><mi>n</mi><mo>-</mo><mn>2</mn><mo>&rpar;</mo><mo>+</mo><mn
    >3</mn><mi>f</mi><mo>&lpar;</mo><mi>n</mi><mo>-</mo><mn>3</mn><mo
    >&rpar;</mo></math> if <math><mi>n</mi><mo>&gt;</mo><mn>3</mn></math>.
    Write a procedure that computes <math><mi>f</mi></math> by means of a
    recursive process. Write a procedure that computes <math><mi>f</mi></math>
    by means of an iterative process.
  </p>
  <textarea name="e1.11-01"></textarea>
  <output for="e1.11-01" class="block">&nbsp;</output>
</section>

<section id="e1.12">
  <h5><a href="#e1.2">Exercise 1.12</a></h5>
  <p>
    The following pattern of numbers is called <em>Pascal's triangle</em>.
  </p>
  <figure>
    <math>
      <mtable>
        <mtr>
          <mtd><mn>1</mn></mtd>
        </mtr>
        <mtr>
          <mtd><mn>1</mn>&emsp;<mn>1</mn></mtd>
        </mtr>
        <mtr>
          <mtd><mn>1</mn>&emsp;<mn>2</mn>&emsp;<mn>1</mn></mtd>
        </mtr>
        <mtr>
          <mtd><mn>1</mn>&emsp;<mn>3</mn>&emsp;<mn>3</mn>&emsp;<mn>1</mn></mtd>
        </mtr>
        <mtr>
          <mtd><mn>1</mn>&emsp;<mn>4</mn>&emsp;<mn>6</mn>&emsp;<mn
          >4</mn>&emsp;<mn>1</mn></mtd>
        </mtr>
        <mtr>
          <mtd>…</mtd>
        </mtr>
      </mtable>
    </math>
  </figure>
  <p>
    The numbers at the edge of the triangle are all 1, and each number inside
    the triangle is the sum of the two numbers above it.<sup id="r1.35s"><a
    href="#r1.35d">35</a></sup> Write a procedure that computes elements of
    Pascal's triangle by means of a recursive process.
  </p>
  <textarea name="e1.12-01"></textarea>
  <output for="e1.12-01" class="block">&nbsp;</output>
</section>

<section id="e1.13">
  <h5><a href="#e1.13">Exercise 1.13</a></h5>
  <p>
    Prove that <math><mtext>Fib</mtext><mo>&lpar;</mo><mi>n</mi><mo
    >&rpar;</mo></math> is the closest integer to <math><msup><mi>ϕ</mi><mi
    >n</mi></msup><mo>/</mo><msqrt><mn>5</mn></msqrt></math>, where <math><mi
    >ϕ</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn
    >5</mn></msqrt></mrow><mn>2</mn></mfrac></math>. Hint: Let <math><mi
    >ψ</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>-</mo><msqrt><mn
    >5</mn></msqrt></mrow><mn>2</mn></mfrac></math>. Use induction and the
    definition of the Fibonnaci numbers (see section <a href="#s1.2.2"
    >1.2.2</a>) to prove that <math><mtext>Fib</mtext><mo>&lpar;</mo><mi
    >n</mi><mo>&rpar;</mo><mo>=</mo><mfrac><mrow><msup><mi>ϕ</mi><mi
    >n</mi></msup><mo>-</mo><msup><mi>ψ</mi><mi>n</mi></msup></mrow><msqrt><mn
    >5</mn></msqrt></mfrac></math>.
  </p>
</section>
</section>
</main>

<nav>
  <menu>
    <li><a href="#s0">Preamble</a></li>
    <li><a href="#s1">1 Building Abstractions with Procedures</a></li>
  </menu>
</nav>

<footer>
  <h2>Attribution</h2>
  <p>
    <a href="https://creativecommons.org/licenses/by-sa/4.0/"><img
      src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a> <br>
    Structure and Interpretation of Computer Programs by <a
    href="https://mitpress.mit.edu/sicp">Harold Abelson and Gerald Jay Sussman
    with Julie Sussman</a> is licensed under a <a
    href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons
    Attribution-ShareAlike 4.0 International License</a> by the MIT Press.
  </p>
</footer>
</body>